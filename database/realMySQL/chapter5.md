# 트랜잭션과 잠금
- 잠금(Lock)은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능

## 트랜잭션
### MySQL에서의 트랜잭션
- 트랜잭션은 하나의 논리적인 작업 셋에 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.
  - commit 되거나 rollback 되거나
### 주의사항
- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋음
  - 트랜잭션의 범위를 최소화할 것
## MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금
  - MySQL 엔진 레벨
  - 스토리지 엔진 레벨
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미침
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
### 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로 획득
- MySQL에서 제공하는 잠금 가운데 가장 범위가 큼
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 문장을 실행할 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
- 서버의 모든 테이블에 대한 쿼리가 오랜 시간 동안 실행되지 못하고 기다릴 수 있음
- 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋음
### 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음
- 명시적
  - LOCK TABLES table_name [ READ : WRITE ]
- 묵시적
  - MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
  - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후 즉시 잠금을 해제하는 형태로 사용
  - 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않음
- InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침
### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아님
- 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금
### 메타데이터 락
데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
## InnoDB 스토리지 엔진 잠금
- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재
- InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM 보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있음
### InnoDB 스토리지 엔진의 잠금
- 잠금 정보가 상당히 작은 공간으로 관리
- 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없음
- InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP)락이 존재
- 레코드 락
  - 레코드 자체만을 잠그는 것을 레코드 락이라고 함
  - InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
  - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
  - 레코드 자체를 잠그느냐, 아니면 인덱스를 잠그느냐는 상당히 크고 중요한 차이를 만들어 냄
  - InnoDB 에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용
  - 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 검
- 갭 락
  - 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미
  - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
  - 갭 락은 넥스트 키 락의 일부로 자주 사용됨
- 넥스트 키 락
  - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
  - STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 함
  - innodb_locks_unsafe_For_binlog 시스템 변수가 비활성화되면(0) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
- 자동 증가 락
  - 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성 제공
  - InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금 사용
  - 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제
  - AUTO_INCREMENT 락은 테이블에 단 하나만 존재
  - 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 함
  - 자동 증가 락을 명시적으로 회득하고 해제하는 방법은 없음
  - MySQL 5.1 이상부터는 innodb_autoinc_lock_mode 라는 시스템 변수를 이용해 자동 증가 락의 작동 방식 변경 가능
  - INSERT 쿼리가 실패해도 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남음
### 인덱스와 잠금
- InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리 됨
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함
### 레코드 수준의 잠금 확인 및 해제
- 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음
  - 레코드 각각에 잠금이 걸리기 때문에