# 트랜잭션과 잠금
- 잠금(Lock)은 동시성을 제어하기 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하기 위한 기능

## 트랜잭션
### MySQL에서의 트랜잭션
- 트랜잭션은 하나의 논리적인 작업 셋에 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.
  - commit 되거나 rollback 되거나
### 주의사항
- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋음
  - 트랜잭션의 범위를 최소화할 것
## MySQL 엔진의 잠금
- MySQL에서 사용되는 잠금
  - MySQL 엔진 레벨
  - 스토리지 엔진 레벨
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미침
- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음
### 글로벌 락
- FLUSH TABLES WITH READ LOCK 명령으로 획득
- MySQL에서 제공하는 잠금 가운데 가장 범위가 큼
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 문장을 실행할 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
- 서버의 모든 테이블에 대한 쿼리가 오랜 시간 동안 실행되지 못하고 기다릴 수 있음
- 웹 서비스용으로 사용되는 MySQL 서버에서는 가급적 사용하지 않는 것이 좋음
### 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음
- 명시적
  - LOCK TABLES table_name [ READ : WRITE ]
- 묵시적
  - MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생
  - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후 즉시 잠금을 해제하는 형태로 사용
  - 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제
- InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않음
- InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침
### 네임드 락
- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
- 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아님
- 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금
### 메타데이터 락
데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
## InnoDB 스토리지 엔진 잠금
- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재
- InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM 보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있음
### InnoDB 스토리지 엔진의 잠금
- 잠금 정보가 상당히 작은 공간으로 관리
- 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없음
- InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP)락이 존재
- 레코드 락
  - 레코드 자체만을 잠그는 것을 레코드 락이라고 함
  - InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠금
  - 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
  - 레코드 자체를 잠그느냐, 아니면 인덱스를 잠그느냐는 상당히 크고 중요한 차이를 만들어 냄
  - InnoDB 에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용
  - 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 검
- 갭 락
  - 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미
  - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
  - 갭 락은 넥스트 키 락의 일부로 자주 사용됨
- 넥스트 키 락
  - 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
  - STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야 함
  - innodb_locks_unsafe_For_binlog 시스템 변수가 비활성화되면(0) 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
- 자동 증가 락
  - 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성 제공
  - InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금 사용
  - 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제
  - AUTO_INCREMENT 락은 테이블에 단 하나만 존재
  - 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 함
  - 자동 증가 락을 명시적으로 회득하고 해제하는 방법은 없음
  - MySQL 5.1 이상부터는 innodb_autoinc_lock_mode 라는 시스템 변수를 이용해 자동 증가 락의 작동 방식 변경 가능
  - INSERT 쿼리가 실패해도 한 번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않고 그대로 남음
### 인덱스와 잠금
- InnoDB 의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리 됨
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함
### 레코드 수준의 잠금 확인 및 해제
- 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않음
  - 레코드 각각에 잠금이 걸리기 때문에
## MySQL의 격리 수준
- 트랜잭션의 격리 수준(isolation level)이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것
- READ UNCOMMITED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE
  - 동시성이 중요한 데이터베이스에서는 거의 사용하지 않음
- 밑으로 내려갈 수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아짐
- 동시 처리 성능도 떨어짐
- SERIALIZABLE 격리 수준이 아니라면 크게 성능의 개선이나 저하는 발생하지 않음

|-|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|---|---|---|---|
|READ UNCOMMITTED|발생|발생|발생|
|READ COMMITTED|없음|발생|발생|
|REPETABLE READ|없음|없음|발생(InnoDB는 없음)|
|SERIALIZABLE|없음|없음|없음|

### READ UNCOMMITTED
- 각 트랜잭션에서의 변경 내용이 COMMIT 이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보임
- 더티 리드(Dirty read) : 트랜잭션 처리 작업이 완료되지 않았으나 다른 트랜잭션에서 볼 수 있는 현상
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않음
- 정합성에 문제가 많음
### READ COMMITTED
- COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
- 변경 쿼리가 발생하면 원본 데이터는 언두 로그에 쌓임
- 다른 트랜잭션에서는 언두 로그의 데이터가 조회됨(MVCC(Multi Version Concurrency Control))
- NON-REPETABLE READ 발생
  - 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 총합을 조회
  - SELECT 쿼리는 실행될 때마다 다른 결과를 가져올 것
### REPEATABLE READ
- MySQL InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- READ COMMITTED 와 REPEATABLE READ 모두 연두 영역 데이터 보여줌
  - 차이점은?
  - 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 버전까지 찾아 들어가야 하느냐에 있음
- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가짐
- 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함돼 있음
- 언두 영역의 백업된 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제
- 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존돼야 함
### SERIALIZABLE
- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
- 동시 처리 성능도 떨어짐
- InnoDB 테이블에서 기본적으로 순수한 SELECT 작업은 아무런 레코드 잠금도 설정하지 않고 실행
- SERIALIZABLE 로 설정되면 읽기 작업도 공유 잠금을 획득해야만 하며
- 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 됨