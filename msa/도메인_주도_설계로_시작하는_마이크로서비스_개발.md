[도메인 주소 설계로 시작하는 마이크로서비스 개발](http://www.yes24.com/Product/Goods/98880996) 을 읽고 정리한 내용입니다.

### 개발자의 역할
 - 문제 영역의 비즈니스 로직을 분석 및 이해하고 프로그래밍 언어라는 도구로 잘 표현하는 일
 - 잘 표현하는 일? 
   - 기능이 잘 동작하는 것
   - 이해하기 쉽고 변경하기 쉬운 시스템을 만드는 것

### 관심사의 분리 (separation of concerns)
- 시스템의 각 영역이 처리하는 관심사가 분리되어 잘 관리돼야 한다는 의미
- 비즈니스를 표현하는 비즈니스 로직 영역과 기술 문제를 처리하기 위한 기술 영역은 철저히 분리 시켜라
- 이것은 비즈니스 로직이 기술보다는 오랫동안 지속되고 안정적이어야 할 애플리케이션의 핵심 영역이기에 기술에 영향을 적게 받도록 설계하는 것을 강조한 데서 기인함

#### 비즈니스 로직을 누가 봐도 이해하기 쉽게 구조화하는 객체 모델로 표현하는 것
#### 애플리케이션의 유지보수성이 높다는 의미는 특정 개인에 의존하기보다는 어느 누구라도 손쉽게 애플리케이션을 이해하고 유지 보수할 수 있음을 의미한다.

### 유연하고 확장성 있는 MSA 시스템을 만들기 위해서는
- 마이크로서비스의 관계들을 유연하게 만드는 MSA 외부 아키텍처 및 패턴도 중요하지만,
- 마이크로서비스의 내부 구조를 어떻게 유연하게 만들 것인지가 가장 중요
  
### 데이터베이스 중심 아키텍처
- 일반적으로 비즈니스 로직은 서비스에 존재해야 한다고 말하지만, 서비스에 존재하게 될 로직은 흐름 제어 로직밖에 없다.
- 그 밖의 비즈니스 개념과 규칙들은 테이블과 SQL 질의에 존재함
- DTO는 질의를 통해 가져오는 정보 묶음의 역할밖에 할 수 없음
- 간단한 처리 로직의 경우에는 편하지만 업무가 복장해지면 점점 복잡성을 제어할 수 없게 된다.

#### 데이터베이스의 본질은 데이터 저장 처리이다.
#### SQL도 비즈니스 로직을 처리하기 위한 언어가 아니라 데이터 처리에 최적화된 언어다.
#### 클라우드의 풍부한 자원 환경에서는 애플리케이션 자체의 성능보다는 애플리케이션의 확장성과 유연함이 더 중요함.
#### 따라서 관심사의 분리 원칙에 따라 끈끈하게 결합돼있던 비즈니스 로직 처리와 데이터 처리를 철저하게 분리하는 것이 필요하다.

### 레이어드 아키텍처
- 프레젠테이션 층 : 화면 표현 및 전환 처리
- 비즈니스 로직 층 : 비즈니스 개념 및 규칙, 흐름 제어
- 데이터 액세스 층 : 데이터 처리
- 인터페이스를 통한 의존성 분리가 중요.
  - 인터페이스를 구현하는 구현체를 다양하게 해주는 다형성을 추구함으로써 제어 흐름을 간접적으로 전환하게 해줌.
- 단점 : OCP에 위배 
  - 모든 계층이 각기 자신이 제공하는 기능에 대한 추상적인 인터페이스를 직접 정의하고 소유하고 있는 구조기 때문
  - 이런 구조에서는 제어 흐름이 상위 계층에서 하위 계층으로 흐르게 됨.
  - 소스코드 의존성은 제어 흐름의 방향대로 따를 수 밖에 없다.

#### 의존성 역전 원칙 (DIP; Dependency Inversion Principle) : 유연성이 극대화된 시스템에서는 소스코드 의존성이 추상에 의존하며, 구체에는 의존하지 않아야 한다.
#### 개방 폐쇄의 원칙 (OCP; Open-Closed Principle) : 소프트웨어 개체는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

### 헥사고날 아키텍처 := ports and adapters architecture
- 내부 영역(고수준의 비즈니스 로직 표현) + 외부 영역(인터페이스 처리를 담당)
- 내부 영역 : 순수한 비즈니스 로직을 표현. 기술 독립적인 영역. 외부 영역과 연계되는 포트를 가지고 있다.
- 외부 영역
  - 인바운드 어댑터 : 외부에서 들어오는 요청 처리
  - 아웃바운드 어댑터 : 비즈니스 로직에 의해 호출되어 외부와 연계

### 클린 마이크로서비스
- 지향하는 관심사에는 응집성 ⬆ 관심사가 다르면 의존도 ⬇
- (업무 규칙 정의)비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력
- 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분
- 고수준 영역은 저수준 영역에 의존하지 않도록, 저수준 영역이 고수준에 의존
- 저수준 영역은 언제든지 교체, 확장 가능 -> 고수준에 영향 X
- 자바 ) 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존
- 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현
  
### 애그리거트 패턴
- 도메인 모델링을 하다 보면 > 객체간 관계 => 참조로 표현
- 일대다 관계의 객체를 쉽게 사용할 수 있다는 장점
- 다만, 업무가 복잡해지면? 
  - 다단계 계층 구조 생기고 참조 관계 복잡 + 무거워짐
  - 모델 내부의 경계가 불명확
  - 비즈니스 일관성이 깨지는 경우가 생김
  - 이를 개선하기 위한 방안으로 최상위에 존재하는 엔티티를 중심으로 개념의 집합을 분리한 것이 애그리거트 패턴

### 외부 영역
- API 퍼블리싱 어댑터
  - REST API를 발행하는 인바운드 어댑터
  - 내부 영역의 서비스 인터페이스를 호출해서 REST 형식의 API로 제공
  - 각 REST 메서드가 의도에 맞게 서비스 인터페이스 호출
  - 엔티티 직접 제공 X API의 필요에 맞는 DTO 생성해서 엔티티를 변환 및 매핑하여 전달하는 것이 바람직
- API 프락시 어댑터 
  - 다른 서비스의 API 호출하는 아웃바운드 어댑터

#### 안타깝게도 애자일 문화가 국내에 유입되는 과정에서 우리나라 특유의 ‘빨리빨리’ 문화와 접목되어 설계가 불필요하고 바로 개발할 수 있는 방식으로 오해받고 있다.
#### 그러나 소프트웨어를 설계하지 않고 곧바로 개발한다는 것은 사실 불가능하다. 아무리 간단한 소프트웨어라도 소스코드를 담을 대략의 프로그램 구조, 모듈, 명명규칙 등을 정의하고 그것들 간의 호출 관계를 생각해야 한다.
#### 애자일에서는 빨리, 그리고 자주 실패를 경험해 보는 것이 중요함. 단순한 설계를 통해 우선 최소한의 실제로 동작하는 제품(MVP; Minimum Viable Product)을 만들어 자주 배포하는 것이 중요함.
     
### 도메인 주도 설계
- 전략적 설계(strategic design)
  - 도메인 전문가 및 기술팀 > 유비쿼터스 언어 통해 도메인 지식 공유 및 이해 > 개념과 경계 식별 > 바운디드 컨텍스트로 정의 > 경계의 관계를 컨텍스트 맵으로 정의
- 전술적 설계(tactical design)
  - 식별된 바운디드 컨텍스트 내의 도메인 개념인 도메인 모델을 구성하는 유용한 모델링 구성요소들을 설명

#### 모듈화의 근본적 가치는 각 모듈을 기능적으로 응집성 높게 만들고, 기능이 다른 타 모듈 간의 의존도를 낮추는 것이다.
#### 마이크로서비스를 구성하는 각 요소들이 모두 소프트, 즉 유연해야 한다는 말과 같다.
     
### 유비쿼터스 언어
- 특정 도메인에서 해당 도메인에서의 의도를 명확히 반영하고 도메인의 핵심 개념을 잘 전달할 수 있는 언어
- 유비쿼터스 언어를 정의해서 이해관계자가 모두 공통의 언어를 사용하면 고객, 설계자, 개발자까지 용어에 따른 오해를 없앨 수 있게 됨.

#### 도메인 모델은 특정 비즈니스 맥락에서 통용되는 개념들의 관계를 잘 정의한 모형.
#### 도메인 모델을 보면 해당 비즈니스를 이해할 수 있어야 함.
     
### 바운디드 컨텍스트
- 도메인 모델들을 구성하다 보면 각 도메인 모델과 다른 도메인 모델 간의 경계가 보임
- 이곳에서 사용하는 언어와 저곳에서 사용하는 언어와 개념이 상이한 이 경계가 바운디드 컨텍스트

### DDD의 전술적 설계(도메인 모델링 구성요소)
- 엔티티 
  - 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체
  - 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있음
- 값 객체 
  - 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링 함.
  - 속성과 속성의 합에 의해 전체 개념이 부여
  - 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체
  - 엔티티와 같이 식별자의 차이에 따라 구별되지 않고 속성과 속성으로 이뤄진 값의 비교에 의해 동일함이 결정됨.
  - 값 객체는 일단 생성되면 변경할 수 없다.
- 표준 타입 
  - 대상의 타입을 나타내는 서술적 객체
  - 엔티티나 값 객체의 속성을 구분하는 용도
  - Ex) 전화번호를 값 객체로 모델링 -> 집 전화인지? 핸드폰 번화인지?
  - Ex) 멤버쉽 등급 유형 -> VIP, GOLD, SILVER
- 애그리거트 
  - 엔티티와 값 객체로 모델링하게 되면 자연스럽게 객체 간의 계층 구조가 만들어짐
  - 이처럼 연관된 엔티티와 값 객체들의 묶음이 애그리거트
  - 애그리거트는 1~2개의 엔티티, 값 객체, 표준 타입 등으로 구성됨.
  - 이들 간에는 비즈니스 의존관계를 맺고 있으며 비즈니스 정합성을 맞출 필요가 있음
  - 따라서 이 애그리거트단위가 트랜잭션의 기본 단위가 됨.
- 도메인 서비스 
  - 도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 하는 것
  - 도메인 서비스에서는 상태를 관리하지 않고 행위만 존재한다.
  - 도메인 로직을 처리할 때 엔티티나 값 객체와 함께 특정 작업을 처리하고 상태를 본인이 가지고 있지 않고 엔티티나 값 객체에 전달함.
- 도메인 이벤트 
  - DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체 
  - 서비스 간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링
  - 이벤트 발행은 주문 처리를 수행하는 트랜잭션과 묶어서 실행돼야 함.
  - 이벤트는 메시지 메커니즘을 통해 다른 서비스에 전달되며 이를 통해 배송 서비스는 배송 처리를 수행함.
