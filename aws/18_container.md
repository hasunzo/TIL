# Docker
## 도커란
- 도커는 앱 배포를 위한 소프트웨어 개발 플랫폼
- 컨테이너 기술
- 컨테이너 앱이 패키징되는데 컨테이너는 표준화되어있어서 아무 운영체제에서나 실행할 수 있음
- 앱이 컨테이너에 패키징되면 어느 운영체제에서든 같은 방식으로 실행
- 아무 머신이나 상관 없이 호환성 문제가 없음
- 행위 특성도 예측 가능해서 작업을 덜어주고 유지 및 배포가 쉽고 언어, 운영체제, 기술에 상관 없이 실행이 가능
- 도커의 사용 사례에는 마이크로서비스 아키텍처가 있음
- 온프레미스에서 클라우드로 앱을 리프트-앤-시프트하기도 하고 컨테이너를 실행하는 어떤 경우에도 사용할 수 있음
## 도커는 운영체제에서 어떻게 작동할까?
- 우선 서버가 있음
- 도커 에이전트를 실행하면 도커 컨테이너를 시작할 수 있음
- 첫 번째 도커 컨테이너는 Java 애플리케이션을 포함하고 두 번째 도커 컨테이너에는 Node.js 애플리케이션을 포함....
- 다수의 도커 컨테이너가 동시에 실행될 수 있어서 Java 애플리케이션을 가진 여러 도커 컨테이너가 있을 수 있고
- Node.js 애플리케이션을 가진 도커 컨테이너도 여러 개 있을 수 있음
- 도커 내에서 MySQL 등의 데이터베이스도 실행 가능하니 아주 다용로도 활용됨
- 서버 관점에서는 모두 도커 컨테이너로 보임
## 도커 이미지는 어디에 저장될까?
- 도커 리포지토리에 저장됨
### 옵션
- Docker Hub은 아주 유명한 퍼블릭 리포지토리로 많은 기술에 맞는 기본 이미지를 찾을 수 있음
  - Ubuntu나 MySQL과 같은 OS용 기본 이미지도 마찬가지
- 프라이빗 리포지토리인 Amazon ECR 즉 Amazon Elastic Container Registry도 있음
- 비공개 이미지를 실행할 수 있지만 Amazon ECR Public Gallery라 불리는 퍼블릭 리포지토리 옵션도 있음
## 도커와 가상 머신의 차이점
- 도커 역시 가상화 기술의 일종이긴 하지만 순전히 가상화 기술은 아님
  - 리소스가 호스트와 공유되어 한 서버에서 다수의 컨테이너를 공유할 수 있음
- 가상 머신의 아키텍처를 살펴보면 인프라와 호스트 운영체제가 있고
  - 그 위에 하이퍼바이저, 앱과 Guest 운영 체제가 있음 (EC2의 원리)
  - 다시 말해 EC2 머신은 하이퍼바이저에 실행되는 가상 머신과도 같다
  - 그래서 Amazon이 EC2 인스턴스를 다양한 소비자에게 제공할 수 있으며 가상 머신의 EC2 인스턴스는 각자 분리되어 있고 리소스를 공유하지 않음
- 도커 컨테이너의 경우 인프라와 EC2 인스턴스 같은 호스트 OS가 있고 도커 Daemon 위에 많은 컨테이너가 있음
  - 도커 Daemon에서 가볍게 실행되는 컨테이너라 공존할 수 있는 것
  - 네트워킹이나 데이터 등을 공유할 수도 있음
  - 소위 말해 가상 머신보다 덜 안전하지만 하나의 서버에 많은 컨테이너를 실행할 수 있기 때문에 도커 컨테이너를 많이 사용함
## 도커 시작하기
- 도커를 시작하려면 우선 Dockerfile을 작성해야 함
  - 도커 컨테이너를 구성하는 파일
- 베이스 도커 이미지에 몇 가지 파일을 추가해서 구축하면 도커 이미지가 됨
- 도커 이미지는 푸시(push)를 해서 도커 리포지토리에 저장할 수 있음
- 퍼블릭 리포지토리인 Docker Hub에 푸시하거나 Amazon 버너의 도커 리포지토리인 Amazon ECR에 푸시
- 나중에 도커 리포지토리에서 이미지를 가져와서 실행하게 되는데 도커 이미지를 실행하면 도커 컨테이너가 되고 도커를 구축할 때 사용했던 코드를 실행할 것
## AWS에서 도커 컨테이너를 어떻게 관리할까?
- Amazon ECS (Elastic Container Service)
  - 도커 관리를 위한 Amazon의 전용 플랫폼
- Amazon EKS (Elastic Kubernetes Service)
  - Kubernetes의 관리형 버전으로 오픈 소스 프로젝트
- AWS Fargate
  - Amazon의 서버리스 컨테이너 플랫폼
  - ECS와 EKS 둘 다 함께 작동할 수 있음
- Amazon ECR
  - 컨테이너 이미지를 저장하는 데 사용

# Amazon ECS
## Amazon ECS의 시작 유형
### EC2 시작 유형(Launch Type)
- ECS (Elastic Container Service)
- AWS에서 컨테이너를 실행하면 ECS 클러스터에 이른바 ECS 태스크를 실행
- ECS 클러스터에는 들어있는 게 있는데 EC2 시작 유형을 사용하면 EC2 인스턴스가 들어있음
- EC2 시작 유형으로 EC2 클러스터를 사용할 때는 인프라를 직접 프로비저닝하고 유지해야 함
- 즉 Amazon ECS 및 ECS 클러스터가 여러 EC2 인스턴스로 구성
- 이떄 ECS 인스턴스는 특별하게 각각 ECS 에이전트(Agent)를 실행해야 함
- 그럼 ECS 에이전트가 각각의 EC2 인스턴스를 Amazon ECS 서비스와 지정된 ECS 클러스터에 등록함
- 이후에 ECS 태스크를 수행하기 시작하면 AWS가 컨테이너를 시작하거나 멈출 것
- 즉 새 도커 컨테이너가 생기면 시간에 따라 EC2 인스턴스에 지정될 것
- ECS 태스크를 시작하거나 멈추면 자동으로 위치가 지정됨
### Fargate 시작 유형
- 마찬가지로 AWS에 도커 컨테이너를 실행하는데 이번에는 인프라를 프로비저닝하지 않아 관리할 EC2 인스턴스가 없음 - 서버리스
- 서버를 관리하지 않아 서버리스라 부르는데 서버가 없는 건 아님
- Fargate 유형은 ECS 클러스터가 있을 때 ECS 태스크를 정의하는 태스크 정의만 생성하면 필요한 CPU나 RAM에 따라 ECS 태스크를 AWS가 대신 실행함
- 즉 새 도커 컨테이너를 실행하면 어디서 실행되는지 알리지 않고 그냥 실행됨
- 작업을 위해 백엔드에 EC2 인스턴스가 생성될 필요도 없음
- 확장하려면 간단하게 태스크 수만 늘리면 됨
- EC2 인스턴스를 관리할 필요가 없음
- 시험에서는 서버리스인 Fargate를 사용하라는 게 자주 나오는데 EC2 시작 유형보다 관리가 쉽기 때문이다
## Amazon ECS 태스크의 IAM 역할
### EC2 Instance Profile (EC2 Launch Type only)
- EC2 인스턴스가 도커에 ECS 에이전트를 실행한다고 하자
- EC2 시작 유형을 사용한다면 EC2 인스턴스 프로파일을 생성
- ECS 에이전트만이 EC2 인스턴스 프로파일을 사용하며 그 EC2 인스턴스 프로파일을 이용해 API 호출을 할 것
- 그럼 인스턴스가 저장된 ECS 서비스가 CloudWatch 로그에 API 호출을 해서 컨테이너 로그를 보내고 ECR로부터 도커 이미지를 가져옴
- Secrets Manager나 SSM Parameter Store에서 민감 데이터를 참고하기도 함
### EC2 Task Role
- EC2와 Fargate 시작 유형에 모두 해당됨
- 두 개의 태스크가 있다면 각자에 특정 역할을 만들 수 있음
- 태스크 A는 EC2 태스크 A 역할을 맡고
- 태스크 B는 EC2 태스크 B 역할을 맡는 것
- 역할을 다르게 하는 이유는?
  - 역할이 각자 다른 ECS 서비스에 연결할 수 있게 하기 떄문
  - 예를 들어 EC2 태스크 A 역할은 태스크 A가 Amazon S3에 API 호출을 실행할 수 있도록 한다면 
  - 태스크 B 역할은 DynamoDB에 API 호출을 실행할 수 있도록 함
  - ECS 서비스의 태스크 정의에서 태스크 역할을 정의함
## Amazon ECS 로드 밸런서 통합
- 여러 ECS 태스크들이 실행되고 ECS 클러스터 안에 있을 때,
- HTTP나 HTTPS 엔드 포인트로 태스크를 활용하기 위해 애플리케이션 로드 밸런서(ALB)를 앞에서 실행하면
- 모든 사용자가 ALB 및 백엔드의 ECS 태스크에 직접 연결됨
- ALB는 이 경우를 포함해 대부분의 사용 사례를 지원하는 좋은 옵션
- 네트워크 로드 밸런서(NBL)는 처리량이 매우 많거나 높은 성능이 요구될 때만 권장
- 구세대 Elastic Load Balancer(ELB)는 사용할 순 있지만 권장하진 않음
  - 고급 기능이 없고 ELB는 Fargate에 연결할 수 없기 때문
- 반면 애플리케이션 로드 밸런서(ALB)는 Fargate와도 사용할 수 있다
## Amazon ECS의 데이터 지속성 Data Volumes (EFS)
- EC2 태스크에 파일 시스템(EFS)를 직접 마운트 할 수 있음
- EC2, Fargate 시작 유형 모두 호환가능
- 어느 AZ에 실행되는 태스크든 Amazon EFS에 연결되어 있다면 데이터를 공유할 수 있고 원한다면 파일 시스템을 통해 다른 태스크와 연결할 수 있음
- Fargate + EFS = Serverless
- 새로운 사례로는 EFS와 ECS를 함께 사용해서 다중 AZ가 공유하는 컨테이너 영구 스토리지가 있음
- 하나 알아 두어야 할 것
  - Amazon S3는 ECS 태스크에 파일 시스템으로 마운트될 수 없다
## Amazon ECS - 오토 스케일링
- 태스크 수를 자동으로 늘리거나 줄일 수 있음
- AWS의 Auto Scaling 서비스를 사용하면 세 개의 지표에 대해 확장이 가능함
  - CPU 사용률
  - RAM
  - ALB 관련 지표인 타겟당 요청 수
- 스케일링 종류
  - Target Tracking(대상 추적)
  - Step Scaling(단계)
  - Scheduled Scaling(예약)
- EC2 시작 유형이라면 태스크 레벨에서의 ECS 서비스 확장이 EC2 인스턴스 클러스터의 확장과 다르다는 사실을 기억할 것
- 따라서 EC2 오토 스케일링이 필요하지 않다면 (백엔드에 EC2 인스턴스가 없다면) Fargate를 사용하는 것이 서비스 오토 스케일링에 도움이 됨
### EC2 오토 스케일링
- Auto Scaling Group Scaling(ASG)
  - CPU 사용률에 따라 ASG를 확장한다고 하면 CPU 사용률이 급등할 때 EC2 인스턴스를 추가
- ECS Cluster Capacity Provider 클러스터 용량 공급자
  - 새 태스크를 실행할 용량이 부족하면 자동으로 ASG를 확장
  - Capacity Provider는 오토 스케일링 그룹과 함께 사용되며 RAM이나 CPU가 모자랄 때 EC2 인스턴스를 추가함
- ASG, 클러스터 용량 공급자 중 선택한다면?
  - EC2 시작 유형의 경우 클러스터 용량 공급자 사용할 것
## Amazon ECS - 솔루션 아키텍트
### ECS 태스크
- EventBridge 로 작동
- Amazon ECS 클러스터가 있고 이와 함께 Fargate와 S3 버킷이 있는 예시
  - 사용자가 S3 버킷에 객체 업로드
  - S3가 Amazon EventBridge와 통합 -> 이벤트 모두 보내기 가능
  - Amazon EventBridge 에는 ECS 태스크를 실행하는 규칙을 만들 수 있음
  - 그럼 ECS 태스크가 생성되고 관련 ECS 태스크 역할이 주어짐
  - 태스크는 객체를 받아 처리하고 Amazon DynamoDB에 결과를 보냄 (ECS 태스크 역할이 결합된 덕)
  - 도커 컨테이너를 이용해 S3 버킷으로부터 이미지나 객체를 처리하는 서버리스 아키텍처 완성
- EventBridge Schedule(일정) 예시
  - Fargate와 EventBridge를 사용하는 ECS 클러스터가 있다고 가정
  - 한 시간마다 트리거되는 규칙의 일정을 만들면 Fargate에서 ECS 태스크를 실행
  - 즉, 한 시간마다 Fargate 클러스터에 새 태스크가 생성
  - 태스크에는 자유롭게 Amazon S3에 접근 가능한 ECS 태스크 역할 등을 생성하면
  - 태스크, 도커 컨테이너, 프로그램이 Amazon S3의 파일에 대해 한 시간마다 배치(Batch) 처리를 하게 됨
  - 이때 아키텍처는 서버리스
- SQS Queue 예시
  - ECS의 서비스에 두 개의 태스크가 있고 SQS 대기열(Queue)에 메시지를 전송했다고 가정
  - 서비스 자체적으로 SQS 대기열로부터 메시지를 가져와서(pull) 처리
  - 여기에 ECS 서비스 오토 스케일링을 활성화하면 SQS 대기열에 메시지가 많아질수록 ECS 서비스에 태스크가 많아짐

# Amazon ECR
- Elastic Container Registry
- AWS에 도커 이미지를 저장하고 관리하는 데 사용
- 계정에 한해 이미지를 비공개로 저장하는 private 방식과
- public 저장소를 사용해 Amazon ECR Public Gallery에 게시하는 방법이 있음
- ECR은 Amazon ECS와 완전히 통합되어 있고 이미지는 백그라운드에서 Amazon S3에 저장됨
- ECR 저장소에 여러 도커 이미지가 있는데 ECS 클러스터의 EC2 인스턴스에 이미지를 끌어오기 위해서는 EC2 인스턴스에 IAM 역할을 지정하면 됨
- ECR에 대한 모든 접근은 IAM이 보호하고 있음
- 이미지의 취약점 스캐닝, 버저닝 태그 및 수명 주기 확인을 지원
- 도커 이미지를 저장할 때는 ECR 기억하기

# Amazon EKS
- Amazon Elastic Kubernetes Service
- AWS에 관리형 Kubernetes 클러스터를 실행할 수 있는 서비스
## Kubernetes란?
- 오픈 소스 시스템으로 Docker로 컨테이너화한 애플리케이션의 자동 배포, 확장, 관리를 지원함
- 컨테이너를 실행한다는 목적은 ECS와 비슷하지만 사용하는 API가 다름
- ECS는 오픈 소스가 아닌 반면 Kubernetes 오픈 소스이고 여러 클라우드 제공자가 사용하므로 표준화를 기대할 수 있음
## EKS의 실행 모드
1. EC2 시작 모드
- EC2 인스턴스에서처럼 작업자 모드를 배포할 때 사용
2. Fargate 모드
- EKS 클러스터에 서버리스 컨테이너를 배포할 때 사용
## EKS 사용 사례
- 회사가 온프레미스나 클라우드에서 Kubernetes나 Kubernetes API를 사용 중일 때
  - Kubernetes 클러스터를 관리하기 위해 Amazon EKS를 사용함
- 클라우드 또는 컨테이너 간 마이그레이션을 실행하는 경우
  - Kubernetes는 클라우드 애그노스틱으로 Azure, Google Cloud 등 모든 클라우드에서 지원되기 떄문
## EKS의 여러 노드 유형
- 관리형 노드 그룹
  - AWS로 노드, 즉 EC2 인스턴스를 생성하고 관리함
  - 노드는 EKS 서비스로 관리되는 오토 스케일링 그룹의 일부
  - 온디맨드 인스턴스와 스팟 인스턴스를 지원함
- 자체 관리형 노드
  - 사용자 지정 사항이 많고 제어 대상이 많은 경우 직접 노드를 생성하고 EKS 클러스터에 등록한 다음 ASG의 일부로 관리해야 함
  - 사전 빌드된 AMI인 Amazon EKS 최적화 AMI를 사용하면 시간을 절약할 수 있음
  - 온디맨드 인스턴스와 스팟 인스턴스를 지원함
- AWS Fargate
  - 노드를 원치 않을 때 사용
  - 유지 관리도 필요 없고 노드를 관리하지 않아도 됨
  - Amazon EKS에서 컨테이너만 실행하면 됨
## EKS Data Volumes
- EKS 클러스터에 데이터 볼륨을 연결하려면 EKS 클러스터에 스토리지 클래스 매니페스트를 지정해야 함
- 컨테이너 스토리지 인터페이스(CSI)라는 규격 드라이버를 활용 (시험)
- 지원
  - Amazon EBS
  - Amazon EFS (works with Fargate)
  - Amazon FSx for Lustre
  - Amazon FSx for NetApp ONTAP

# AWS App Runner
- 완전 관리형 서비스로 규모에 따라 웹 애플리케이션, API 배포를 도움
- 이 서비스로는 누구나 AWS에 배포를 할 수 있음
- 인프라나 컨테이너, 소스 코드 등을 알 필요가 없음
- 먼저 소스 코드나 Docker 컨테이너 이미지를 가지고 원하는 구성을 설정
- vCPU의 수나 컨테이너 메모리의 크기, 오토 스케일링 여부 상태 확인을 설정하면 됨
- 웹 애플리케이션이나 API에 들어갈 기본 설정을 설정하는 것
- 다음 작업은 자동으로 이루어짐
- App Runner 서비스가 웹 앱을 빌드하고 배포
- 컨테이너가 생성되고 배포됨
- API나 웹 앱이 배포된 다음엔 URL을 통해 바로 액세스할 수 있음
- 이처럼 배후에서 어떤 작업이 이뤄지는지 전혀 몰라도 배포할 수 있음
- 오토스케일링이 가능하고 가용성이 높음
- 로드 밸런싱 및 암호화 기능을 지원함
- 애플리케이션, 즉 컨테이너가 VPC에 액세스할 수도 있어서 데이터베이스와 캐시 메시지 대기열 서비스에 연결할 수 있음
- 사용 사례로는 빨리 배포해야 하는 웹 앱, VPI 그리고 마이크로서비스가 있음
- 신속한 프로덕션 배포가 필요할 때 사용