# CHAPTER1 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?



## 1.1 역사의 흐름은 무엇인가?
- 자바 역사를 통틀어 가장 큰 변화가 일어난 자바 8
> 예시 ) 사과 목록을 무게순으로 정렬
- 고전 코드
```java
Collections.sort(inventory, new Comparator<Apple>()) {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
}
```
- 자바 8
```java
inventory.sort(comparing(Apple::getWeight));
```
- 지금까지의 대부분의 자바 프로그램은 코어 중 하나만을 사용했다.
- 자바 8이 등장하기 이전에는 나머지 코어를 사용하려면 스레드를 사용하는 것이 좋다고 조언했을 것이다.
- 하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다.
- 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.
- 자바 8에서 등장한 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법
    - 자바 8의 새로운 기법을 이용하려면 몇 가지 규칙을 지켜야 한다. 이 책에서 그 규칙을 설명한다.
    
#### 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.

> 자바 8에서 제공하는 새로운 기술
- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

#### 스트림 API
- 데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 구현하면, 최적의 저수준 실행 방법을 선택하는 방식으로 동작한다.
- 스트림을 이용하면 synchronized (에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드)를 사용하지 않아도 된다.
- 스트림 API 덕분에 메서드에 코드를 전달하는 간결 기법 (메서드 참조와 람다), 인터페이스의 디폴트 메서드가 존재

#### 메서드에 코드를 전달하는 기법을 이용하면 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있다.
- 약간만 다른 두 메서드가 있을 경우 두 메서드를 그대로 두는 것보다는 인수를 이용해서 하나의 메서드로 합치는 것이 바람직하다.
- 이렇게 되면 복사 및 붙여넣기를 하는 것에 비해 짧고 간결해지고 불필요한 메서드를 줄일 수 있다.

#### 메서드에 코드를 전달하는 자바 8 기법은 함수형 프로그래밍에서 위력을 발휘한다.
- 코드를 전달하거나 조합해서 자바의 강력한 프로그래밍 도구로 활용할 수 있다는 것을 이 책 전반에서 확인할 수 있다.


## 1.2 왜 아직도 자바는 변화하는가?
> 자바가 멀티코어 병렬성 (기존의 자바에서 부족했던 특성)을 더 쉽게 이용할 수 있도록 진화하는 과정과 관련 개념을 설명한다.
- 피터 랜딘은 1966년에 이미 프로그래밍 언어가 700개에 이르며 앞으로 어떤 700개의 프로그래밍 언어가 나올 것인지 논의했다.
- 이후로 수천 개의 언어가 쏟아져 나왔다.
- 새로운 언어가 등장하며 진화하지 않은 언어는 사장되었다.
- 특정 분야에서 장점을 가진 언어는 다른 경쟁 언어를 도태시킨다.
- 자바는 지난 1955년 첫 베타 버전이 공개된 이후로 경쟁 언어를 대신하며 커다란 생태계를 성공적으로 구축했다.

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치
- 자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다.
- 자바는 처음부터 스레드와 락을 이용한 소소한 동시성도 지원했다.
- 코드를 JVM 바이트 코드로 컴파일하는 특징 때문에 자바는 인터넷 애플릿 프로그램의 주요 언어가 되었다.
- 자바는 다양한 임베디드 컴퓨팅 분야를 성공적으로 장악하고 있다.

> 자바는 어떻게 대중적인 언어로 성장했는가?
>> 객체지향은 1990년대에 두 가지 이유로 각광받았다.
>> - 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다는 점
>> - 객체지향의 정신적인 모델 덕분에 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있다는 사실
>> - '모든 것은 객체다' > 마이크로소프트의 C#은 자바 형식의 객체지향 모델의 힘을 깊이 있게 검증해주었다.

#### 하지만 프로그래밍 언어 생태계에 변화의 바람이 불었다.
- 프로그래머는 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다.
- 즉, 병령 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응하기가 어려웠다.

#### 생태계를 요약하자면 새로운 언어가 등장하고 새로운 언어는 변화하는 환경에 빠르게 적응하면서 점점 대중화된다.
- 자바 8은 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수할 수 있다는 장점을 제공한다.
- 자바 8에 추가된 기능은 자바에 없던 완전히 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다.

### 1.2.2 스트림 처리
- 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
- 이론적으로 프로그램은 입력 스트림에서 데이터를 한개씩 읽어 들이며 출력 스트림으로 데이터를 한 개씩 기록한다.
- 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

#### 스트림 처리 예시 ) 자바
- 자바 ) 표준 입력 (System.in)에서 데이터를 읽은 후 데이터를 처리하고, 결과를 표준 출력 (System.out)으로 기록한다.

#### 스트림 처리 예시 ) 유닉스
```shell
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```
- 유닉스의 cat 명령 ) 두 파일을 연결해서 스트림을 생성하며, tr은 스트림의 문자를 변역하고, sort는 스트림의 행을 정렬하며, tail -3은 스트림의 마지막 3개 행을 제공한다.
- 파일의 단어를 소문자로 바꾼 다음 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램
- sort는 여러 행의 스트림을 입력으로 받아 여러 행의 스트림을 출력으로 만들어낸다.
- 유닉스에서는 여러 명령(cat, tr, sort, tail)을 병렬로 실행한다.
- 따라서 cat이나 tr이 완료되지 않은 시점에서 sort가 행을 처리하기 시작할 수 있다.

#### 스트림 처리 예시 ) 자동차 생산 공장 라인
- 자동차 생산 공장은 여러 자동차로 구성된 스트림을 처리한다.
- 각각의 작업장에서는 자동차를 받아서 수리한 다음에 다음 작업장에서 다른 작업을 처리할 수 있도록 넘겨준다.
- 조립 라인은 자동차를 물리적인 순서로 한 개씩 운반하지만 각각의 작업장에서는 동시에 작업을 처리한다.

#### 자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다.
- 스트림 패키지에 정의된 Stream\<T\>는 T 형식으로 구성된 일련의 항목을 의미한다.
- 우선은 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자.
- 이전 예제에서 유닉스 명령어로 복잡한 파이프라인을 구성했던 것처럼,
- 스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다.
- 기존 자바는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을
- (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다.
- 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다.
- 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다.

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
- 자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.
- 유닉스 예제에서 sort 명령에 파라미터를 추가하고 싶을 수도 있다.
- sort에 파라미터를 제공해서 역순 정렬 등 다양한 정렬을 수행할 수 있지만,
- 어쨌든 sort로 수행할 수 있는 동작은 미리 정해져 있다.
- 자바8 이전의 자바에서는 메서드를 다른 메서드로 전달할 방법이 없었다.
- 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.
    - 이 기능을 동작 파라미터화라고 부른다.
    
### 1.2.4 병렬성과 공유 가변 데이터
> '병렬성을 공짜로 얻을 수 있다.'
- 병렬성을 공짜로 얻는 대신 포기해야 할 것..
    - 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.
    - 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다.
    - 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터에 접근하지 않아야 한다.
- 공유되지 않는 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항이다.
- 반면 명령형 프로그래밍 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다.

### 1.2.5 자바가 진화해야 하는 이유
- 지금까지 자바는 진화해왔다.
    - 제네릭의 등장, List > List\<String\>으로의 변화, Iterator 대신 for-each 구문 사용
> 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그램으로 다가섰다.
- 함수형 프로그래밍에서는 우리가 하려는 작업이 최우선시되며 그 작업을 어떻게 수행하는지는 별개의 문제로 취급된다.
- 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있게 되었다.
- 즉, 어떤 문제를 더 효율적으로 해결할 수 있는 다양한 도구를 얻게 된 것.

> "언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다."

## 1.3 자바 함수
> 자바 8에서 제공하는 코드를 메서드로 전달하는 기법이 어떻게 강력한 새로운 프로그래밍 도구가 될 수 있는지 설명한다.
- 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다.
- 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.
- 자바 8에서는 함수를 새로운 값의 형식으로 추가했다.
    - 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문

> 함수를 값처럼 취급하는 데에서 오는 장점
- 자바 프로그램에서 조작할 수 있는 값
    - 기본값 (int, double)
    - 객체
- new 또는 팩토리 메서드 또는 라이브러리 함수를 이용해서 객체의 값을 얻을 수 있다.
- 객체 참조는 클래스의 인스턴스를 가리킨다.
    - "abc"(String), new Integer(1111)(Integer), new HashMap\<Integer, String\>(100)(HashMap의 생성자를 호출)
- 왜 함수가 필요할까?
    - 프로그래밍 언어의 핵심은 값을 바꾸는 것.
    - 이 값을 일급(first-class)값이라고 부른다.
    - 자바 프로그래밍 언어의 다양한 구조체가 값의 구조를 표현하는 데 도움이 될 수 있다.
    - 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다.
    - 이렇게 전달할 수 없는 구조체는 이급 시민이다.
    - 위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 시민에 해당한다.
    - 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메서드를 아주 유용하게 활용할 수 있지만 여전히 메서드와 클래스는 그 자체로 값이 될 수 없다.
    - 런타임에 메서드를 전달할 수 있다면? 즉, 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다.
    - 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.
    - 클래스 같은 이급 시민도 일급시민으로 바꿀 수 있다면 좋지 않을까?
    
### 1.3.1 메서드와 람다를 일급 시민으로
> 자바 8의 설계자들은 메서드를 값으로 취급할 수 있게, 그리하여 프로그래머들이 더 쉽게 프로그램을 구현할 수 있는 환경이 제공되도록 자바 8을 설계하기로 결정했다.
#### 메서드 참조
- 디렉터리에서 모든 숨겨진 파일을 필터링 한다고 가정
    - 주어진 파일이 숨겨져 있는지 여부를 알려주는 메서드 구현
    - File 클래스의 isHidden 메서드 > File 클래스를 인수로 받아 boolean을 반환하는 함수
    - FileFilter 객체 내부에 위치한 isHidden의 결과를 File.listFiles 메서드로 전달하는 방법으로 숨겨진 파일을 필터링할 수 있다.
```java
File[] hiddenFiles = new File(".").isFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
})
```
- 위 코드는 각 행이 무슨 작업을 하는지 투명하지 않다.
- File 클래스에는 이미 isHidden이라는 메서드가 있는데 왜 굳이 FileFilter로 isHidden을 복잡하게 감싼다음에
FileFilter를 인스턴스화해야 할까?
- 자바 8이 나타나기 전까지는 달리 방법이 없었다.

#### 자바 8에서는 다음처럼 코드를 구현할 수 있다.
```java
File[] hiddenFiles = new File(".")listFiles(File::isHidden);
```
- 이미 isHidden이라는 함수는 준비되어 있으므로
- 자바 8의 메서드 참조 :: ('이 메서드를 값으로 사용하라'는 의미)를 이용해서
- listFiles에 직접 전달할 수 있다.

#### 람다 : 익명 함수
- 자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다.
- (int x) -> x+1, 즉 'x라는 인수로 호출하면 x+1를 반환' 하는 동작을 수행하도록 코드를 구현할 수 있다.
- 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.
- 람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 '함수를 일급값으로 넘겨주는 프로그래밍을 구현한다'라고 한다.

### 1.3.2 코드 넘겨주기 : 예제
> Apple 클래스, getColor 메서드, Apples 리스트를 포함하는 변수 inventory 가정
- 모든 녹색 사과를 선택해서 리스트를 반환하는(filterGreenApples) 프로그램
- 특정 항목을 선택해서 반환하는 동작을 '필터' 라고 한다.
- 자바 8 이전의 메서드
```java
public static List<Apple> fileGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    
    for (Apple apple: inventory) {
        if (GREEN.equals(apple.getColor())) {
            result.add(apple);
        }
    }
    return result;
}
```
- 사과를 무게로 필터링하는 코드는 다음과 같이 구현할 것이다. (전체 코드를 복사&붙여넣기해서..)
```java
public static List<Apple> fileGreenApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    
    for (Apple apple: inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```
- 복사&붙여넣기의 단점 (어떤 코드에 버그가 있다면 복붙한 모든 코드를 고쳐야 한다.)
- 이 예제에서 두 메서드는 한 줄의 코드만 다르다.

- 자바 8에서는 코드를 인수로 넘겨줄 수 있다.
- filter 메서드를 중복으로 구현할 필요가 없다.
```java
// 녹색 사과 찾기
public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
}

// 무게로 찾기
public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

// 명확히 하기 위해 추가함
public interface Predicate<T> {
    boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple: inventory) {
        if (p.test(apple)) {    // 사과는 p가 제시하는 조건에 맞는가?
            result.add(apple);
        }
    }
    return result;
}
```
- 다음처럼 메서드를 호출할 수 있다.
```java
filterApples(inventory, Apple::isGreenApple);
```
- 또는 다음과 같이 호출해도 된다.
```java
filterApples(inventory, Apple::isHeavyApple);
```

> 프레디케이트(predicate)란 무엇인가?
> > 앞에서 다룬 예제에서는 Apple::isGreenApple로 넘겨주었다. 수학에서는 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다.

### 1.3.3 메서드 전달에서 람다로
- 한 두번만 사용할 메서드를 매번 정의하는 것은 귀찮다. (isHeavyApple, isGreenApple)
- 자바 8에서는 이 문제도 간단히 해결한다.
- 자바 8에서는 (익명 함수 또는 람다라는) 새로운 개념을 이용해서 코드를 구현한다.
```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventoty, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));
```
- 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.
- 하지만 람다가 몇 줄 이상으로 길어진다면 익명 람다보다는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다.
- 코드의 명확성이 우선시되어야 한다.

> 라이브러리 메서드 filter를 이용하면 filterApples 메서드를 구현할 필요가 없다.
```java
filter(inventory, (Apple a) -> a.getWeight() > 150);
```
- 하지만 병렬성이라는 중요성 때문에 설계자들은 이와 같은 설계를 포기했다.
- 대신 자바 8에서는 filter와 비슷한 동작을 수행하는 연산집함을 포함하는 새로운 스트림 API를 제공한다.
- 또한 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공한다.


## 1.4 스트림
> 스트림 API(병렬형 데이터를 표현하고 이들 데이터를 병렬로 처리할 수 있음을 유연하게 보여주는)가 어째서 강력하고 새로운 프로그래밍 도구인지 설명한다.
- 리스트에서 고가의 트랜잭션(Transaction 거래)만 필터링한 다음에 통화로 결과를 그룹화해야 하는 예제
```java
Map<Currency, List<Transaction>> transactionByCurrencies = 
    new HashMap<>();    // 그룹화된 트랜잭션을 더할 Map 생성
for (Transaction transaction : transactions) {  // 트랜잭션의 리스트를 반복
    if (transaction.getPrice() > 1000) {    // 고가의 트랜잭션을 필터링
        Currency currency = transaction.getCurrency();  // 트랜잭션의 통화 추출
        List<Transaction> transactionForCurrency =
            transactionByCurrencies.get(currency);
        if (transactionsForCurrency == null) {  // 현재 통화의 그룹화된 맵에 항목이 없으면 새로 만든다.
            transactionForCurrency = new ArrayList<>();
            transactionByCurrencies.put(currency, transactionsForCurrency);
        }
        transactionsForCurrency.add(transaction);   // 현재 탐색된 트랜잭션을 같은 통화의 트랜잭션 리스트에 추가한다.
    }
}
```
- 위 예제 코드에는 중첩된 제어 흐름 문장이 많아서 코드를 한번에 이해하기가 어렵다.
- 스트림 API를 이용하면 다음처럼 문제를 해결할 수 있다.

```java
import static java.util.stream.Collectors.groupingBy;
Map<Currency, List<Transaction>> transactionsByCurrencies =
    transactions.stream()
            .filter((Transaction t) -> t.getPrice > 1000)   // 고가의 트랜잭션 필터링 
            .collect(groupingBy(Transaction::getCurrency))  // 통화로 그룹화함
```

- 컬렉션에서는 반복 과정을 직접 처리해야 했다.
- 즉 for-each 루프를 이용해서 각 요소를 반복하며 수행했다. >> 외부 반복
- 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. >> 내부 반복


### 1.4.1 멀티스레딩은 어렵다
- 이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다.
- 멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다.
- 결과적으로 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.
> 자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제', '멀티코어 활용 어려움'의 문제를 해결했다.
- 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링 (무게에 따라 사과 선택)
- 데이터를 추출 (리스트에서 각 사과의 무게 필드 추출)
- 데이터를 그룹화 (숫자 리스트의 숫자를 홀수와 짝수로 그룹화함)

#### 컬렉션과 스트림의 차이
- 컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점
- 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점
- 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심

#### 스트림과 람다 표현식을 이용하면 병렬성을 공짜로 얻을 수 있으며 리스트에서 무거운 사과를 순차적으로 또는 병렬로 필터링할 수 있다.
- 순차 처리 방식
```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
    inventory.stream().filter((Apple a) ->> a.getWeigth() > 150)
                        .collect(toList());
```
- 병렬 처리 방식
```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
    inventory.paralleStream().filter((Apple a) -> a.getWeigth() > 150)
                                .collect(toList());
```


## 1.5 디폴트 메서드와 자바 모듈
> 디폴드 메서드라는 새로운 자바 8의 기능을 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는 데 어떻게 활용할 수 있는지 설명한다.
- 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다.
- 인터페이스를 바꿔야 하는 상황에서 인터페이스를 구현하는 모든 클래스의 구현을 바꿔야 했다.
- 자바 8, 자바 9는 이 문제를 다른 방법으로 해결했다.

> 자바 8의 디폴트 메서드
- 인터페이스를 쉽게 바꿀 수 있도록 자바 8은 디폴트 메서드를 지원한다.
- 디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라,
- 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다.
```java
List<Apple> heavyApples =
    inventory.stream().filter((Apple a) ->> a.getWeigth() > 150)
                        .collect(toList());
List<Apple> heavyApples =
    inventory.paralleStream().filter((Apple a) -> a.getWeigth() > 150)
                        .collect(toList());
```
- 자바 8 이전에는 List\<T\>가 stream이나 parallelStream 메서드를 지원하지 않는다는 것이 문제
- 따라서 위 예제는 컴파일할 수 없는 코드다.
- 가장 간단한 해결책은 직접 인터페이스를 만들어서 자바 8 설계자들이 했던 것처럼 Collection 인터페이스에 Stream 메서드를 추가하고
ArrayList 클래스에서 메서드를 구현하는 것이다.

> 어떻게 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경할 수 있을까?
- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다.
- 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다.
  - 그래서 이를 디폴트 메서드라고 부른다.
  
> 자바 8 에서는 인터페이스 구격명세에 default라는 새로운 키워드를 지원한다.
- 예를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다.
- 이는 자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.
```java
default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}
```
- 따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort를 구현해야 했지만 자바 8부터는 디폴트 sort를 구현하지 않아도 된다.


## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
> JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 제시한다.
- 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어를 살펴봤다.
  - 1. 메서드와 람다를 일급값으로 사용
  - 2. 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있다.
- 일반적인 함수형 언어도 프로그램을 돕는 여러 장치를 제공한다.
  - 명시적으로 서술형의 데이터 형식을 이용해 null을 회피하는 기법
  - 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional\<T\> 클래스를 제공한다.
    - Optional\<T\>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다.
    - Optional\<T\>는 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있다.
    - 따라서 Optional\<T\>를 사용하면 NullPointer 예외를 피할 수 있다.
  - 즉, 형식 시스템을 이용해서 어떤 변수에 값이 없을 떄 어떻게 처리할지 명시할 수 있다.
- (구조적) 패턴 매칭 기법
  - 패턴 매칭은 수학에서 다음 예제처럼 사용
```java
f(0) = 1
f(n) = n*f(n-1) 그렇지 않으면
```
- 자바에서는 if-then-else나 switch문을 이용했을 것이다.
- 다른 언어에서는 if-then-else보다 패턴 매칭으로 더 정확한 비교를 구현한다.
- 아쉽게도 자바 8은 패턴 매칭을 완벽하게 지원하지 않는다.

## 1.7 마치며
- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 된다.
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다
- 함수는 일급값이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억하자.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다.
  - 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있게 된다.
- 기존 가바 기능으로는 대규모 컴포넌트 기반 프로그래밍 그리고 진화하는 시스템의 인터페이스를 적절하게 대응하기 어려웠다.
  - 자바 9에서는 모듈을 이용해 구조를 만들 수 있고 디폴트 메소드를 이용해 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도
  인터페이스를 변경할 수 있다.
- 함수형 프로그래밍에서 null 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견했다.















