# 아이템 6 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다
- 재사용은 빠르고 세련되다
- 특히 불변 객체는 언제든 재사용할 수 있다

```java
// 하지 말아야 할 극단적인 예
String s = new String("bikini");
```

- 실행될 때마다 String 인스턴스를 새로 만든다
- 쓸데없는 String 인스턴스가 수백만 개 만들어질 수도 있다

```java
String s = "bikini";
```

- 이 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다
- 나아가 이 방식을 사용한다면 같은 가상 머신 안에서 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다
- Spring pool에 저장될 때 intern() 메소드 실행 → 같은 값이 있을 경우 주소값 반환, 다른 값일 경우 객체 생성 후 메모리 주소 리턴
- Integer, Long.. 등도 마찬가지
    - 얘넨 기본값 (-128 ~ 127)을 컴파일때 캐싱해두고 같은 주소값을 사용
    - 기본값은 조절할 수 있다

```java
Boolean(String) // 생성자
Boolean.valueOf(String) // 팩터리 메서드
```

- 생성자는 호출할 때마다 새로운 객체를 만든다
- 팩터리 메서드는 전혀 그렇지 않다 → 재사용 가능

### 생성 비용이 아주 비싼 객체

- 캐싱하여 재사용하길 권한다
- 자신이 만드는 객체가 비싼객체인지 아닌지 어떻게 아나?

```java
static boolean isRomanNumeral(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
			 + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

- 이 방식의 문제는 String.matches 메서드를 사용하는 데 있다
- String.matches 는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다
- 이 메서드가 내부에서 만드는 정규표현식용 Pattern 인스턴스는 한 번 쓰고 버려져서 가비지 컬렉션 대상이 된다
- Pattern 은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높다

### 개선해보기

```java
public class RomarNumerals {
	private static final Pattern ROMAN = Pattern.compile(
		"^(?=.)M*(C[MD]|D?C{0,3})"
			 + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
	
	static boolean isRomanNumeral(String s) {
		return ROMAN.matcher(s).matches();
	}
}
```

- 이렇게 개선하면 isRomanNumeral 이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다
- 심지어 이름까지 지어주어서 코드의 의미가 훨씬 잘 드러난다

### 불필요한 객체를 만들어내는 예 - 오토박싱(auto boxing)

- 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술
- 오토박싱은 기본 타입과 그에 대응하는 박싱된 기본 타입의 구분을 흐려주지만 완전히 없애주는 것은 아니다
- 박싱
    - 기본형 → 참조형
- 언박싱
    - 참조형 → 기본형
- 오토박싱
    - 박싱과 언박싱이 자동으로
- 오토박싱에는 비용이 소모된다
- boxing한 값은 기본형을 감싸는 래퍼가 되고 이는 힙에 저장이 된다. 힙에 저장되면 메로리를 소비하기 때문에 비용이 소모된다는 것
- 또한 기본형을 가져올때도 메모리 탐색 과정이 필요하다는 점도 비용 소모의 예시다
- 참고로 C# 에는 이런 제약이 없고 스칼라에는 참조형만 존재한다고 한다

```java
private static long sum() {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++)
		sum += i;
	return sum;
}
```

- sum 변수를 long이 아닌 Long 으로 선언해서 불필요한 Long 인스턴스가 231개나 만들어진 것
- 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 주의하자