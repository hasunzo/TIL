# 10 객체지향 쿼리 언어
- JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원함.
- JPQL은 가장 중요한 객체지향 쿼리 언어이다.

## 10.1 객체지향 쿼리 소개
- em.find() 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있음
    - 이렇게 조회한 엔티티에 객체 그래프 탐색을 사용하면 -> 연관된 엔티티들을 찾을 수 있다.

- 식별자로 조회 EntityManager.find()
- 객체 그래프 탐색 a.getB(), getC()

- but, 이 기능만으로 애플리케이션을 개발하기는 어려움
    - 예를 들어 나이가 30살인 회원을 모두 검색하고 싶다면?
        - 모든 회원 엔티티를 메모리에 올려두고
        - 애플리케이션에서 30살 이상인 회원을 검색하는 것은 현실성 없음
        - 결국 -> 데이터는 데이터베이스에 있으므로 SLQ로 필요한 내용을 최대한 걸러서 조회해야 함.
    - ORM을 사용하면?
        - 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발.
        - 검색또한 테이블이 아닌 엔티티 객체를 대상으로 하는 방법이 필요.

- JPQL의 특징
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
    - SLQ을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음

- SQL -> 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리
- JPQL -> 엔티티 객체를 대상으로 하는 객체지향 쿼리
- JPQL을 사용하면 JPA는 이 JPQL을 분석 한 다음 -> 적절한 SQL을 만들어 조회함.
    - 조회한 결과로 엔티티 갤체를 생성해서 반환.

- JPQL = "객체지향 SQL"

#### JPA가 공식 지원하는 기능
- JPQL(Java Persistence Query Language)
- Criteria 쿼리 : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SLQ : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.

#### JPQ가 공식 지원하는 기능은 아니지만 알아둘 가치가 있는 것들
- QueryDSL : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크
- JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용

### 10.1.1 JPQL 소개
- JPQL은 엔티티 객체를 조회하는 객체지향 쿼리.
- 문법은 SQL과 비슷하고 ANSI 표준 SQL이 제공하는 기능을 유사하게 지원함.
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않음
- 데이터베이스 방언만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있음.
### JPQL은 SQL보다 간결하다!

- 회원 엔티티를 대상으로 JPQL을 사용하는 간단한 예제
```java
@Entity(name = "Member")    //name 속성의 기본값은 클래스 명
public class Memebr {
    
    @Column(name = "name")
    private String username;
    //...
}
```
- JPQL 사용
```java
//쿼리 생성
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```
- 예제 코드는 회원이름이 kim인 엔티티를 조회함
- JPQL에서 Member는 엔티티 이름이다.
- m.username은 테이블 컬럼명이 아닌, 엔티티 객체의 필드명이다.
- em.createQuery() 메소드에 실행할 JPQL과 반환할 엔티티의 클래스 타입인 Member.class를 넘겨주고
  getResultList() 메소드를 실행하면 JPA는 JPQL을 SQL로 변환하여 데이터베이스를 조회함.

- 그리고 조회한 결과로 Member 엔티티를 생성하여 반환함

- 실행한 JPQL
```h2
select m 
from Member as m 
where m.username = 'kim'
```
- 실제 실행된 SQL
```h2
select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
from 
    Member member
where
    member.name='kim'
```

### 10.1.2 Criteria 쿼리 소개
- Criteria는 JPQL을 생성하는 빌더 클래스
- Criteria의 장점
    - 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점

- 문자로 작성한 JPQL보다 코드로 작성한 Criteria의 장점
- 컴파일 시점에 오류를 발견할 수 있음
- IDE를 사용하면 코드 자동완성을 지원함
- 동적 쿼리를 작성하기 편함

- 방금 본 JPQL을 Criteria로 작성하면?
```h2
select m from Member as m where m.username = 'kim'
```

- Criteria 쿼리
```h2
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq =
    query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();    
```
- 쿼리를 문자가 아닌 코드로 작성한 것을 확인할 수 있음.
- 아쉬운 점 -> m.get("username") -> 필드 명을 문자로 작성
    - 이 부분도 문자가 아닌 코드로 작성하고 싶다면?
        - 메타 모델을 사용!

- 메타 모델 API?
    - 자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있음
    - JPA는 이 기능을 사용해서 Member 엔티티 클래스로부터 Member_라는 Criteria 전용 클래스를 생성
        - 이것을 메타 모델이라 함

```java
//메타 모델 사용 전 -> 사용 후
m.get("username") -> m.get(Member_.username)
```

### 10.1.3 QueryDSL 소개
- QueryDSL도 Criteria처럼 JPQL 빌더 역할을 함
- QUeryDSL의 장점
    - 코드 기반이면서 단순하고 사용하기 쉬움
    - 작성한 코드도 JPQL과 비슷하여 한눈에 들어옴

- QueryDSL로 작성한 코드
```java
//준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

//쿼리, 결과조회
List<Member> members =
    query.from(member)
    .where(member.username.eq("kim"))
    .list(member);
```

- QueryDSL도 어노테이션 프로세서를 사용해서 쿼리 전용 클래스를 만들어야 함
- QMember는 Member 엔티티 클래스를 기반으로 생성한 QueryDSL 쿼리 전용 클래스

### 10.1.4 네이티브 SQL 소개
- JPA가 제공하는 SQL을 직접 사용할 수 있는 기능
- JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있음
    - 예) 오라클 데이터베이스만 사용하는 CONNECT BY 기능
    - 특정 데이터베이스에서만 동작하는 SQL 힌트...

- 네이티브 SQL의 단점 -> 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것.
- 데이터베이스를 변경하면 네이티브 SQL도 수정해야 함
- 네이티브 SQL

```java
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = 
    em.createNativeQuery(sql, Member.class).getResultList();
```
- 네이티브 SQL은 em.createNativeQuery()를 사용하면 됨
- 실행하면 직접 작성한 SQL을 데이터베이스에 전달함

## 10.2 JPQL
- JPQL의 특징
    - JPQL은 객체지향 쿼리 언어 ->
        - 테이블을 대상으로 쿼리 X 엔티티 객체를 대상
    - JPQL은 SQL을 추상화 -> 특정 데이터베이스 SQL에 의존하지 않음
    - JPQL은 결국 SQL로 변환

### 10.2.1 기본 문법과 쿼리 API
#### SELECT 문
```java
SELECT m FROM Member AS m where m.username = 'hello'
```
- 대소문자 구분
    - 엔티티와 속성은 대소문자 구분 O
        - Member, username
    - SELECT, FROM, AS -> JPQL 키워드는 대소문자 구분 X

- 엔티티 이름
    - JPQL의 Member는 클래스 명 X 엔티티 명임
    - 엔티티 명 지정 -> @Entity(name="XXX")
    - 미지정 시 -> 클래스 명을 기본값으로

- 별칭은 필수
    - Member AS m
        - JPQL은 별칭을 필수로 사용
        - AS 생략 가능

```java
SELECT username FROM Member m // 잘못된 표현 m.username으로 고쳐야함
```

#### TypeQuery, Query
- 작성한 JPQL을 실행하기 위한 쿼리 객체
- TypeQuery
    - 반환할 타입을 명확하게 지정할 수 있을 때
```java
TypedQuery<Member> query = 
        em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for(Member member : resultList) {
    System.out.println("Member = "+ member);
}
```
- em.createQuery()의 두 번째 파라미터에 반환할 타입을 지정
    - 조회 대상이 Member 엔티티이므로 조회 대상 타입이 명확함


- Query
    - 반환 타입을 명확하게 지정할 수 없을 때
```java
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();
        
for(Object o : resultList) {
    Object[] result = (Object[]) o; //결과가 둘 이상이면 Object[] 반환
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```
- 조회 대상이 명확하지 않음 - Query 객체 사용
    - username : String 타입
    - age : Integer 타입

#### 결과 조회
- query.getResultList() : 결과를 예제로 반환함.
    - 결과가 없으면 빈 컬렉션 반환

- query.getSingleResult() : 결과가 정확히 하나일 때 사용
    - 결과가 없으면 javax.persistence.NoResultException 예외 발생
    - 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 예외 발생

- getStringResult()는 결과가 정확히 1개가 아니면 예외가 발생한다는 점에 주의
```java
Member member = query.getSingleResult();
```

### 10.2.2 파라미터 바인딩
- JDBC : 위치 기준 파라미터 바인딩만 지원
- JPQL : 이름 기준 파라미터 바인딩도 지원

#### 이름 기준 파라미터
- 파라미터를 이름으로 구분하는 방법
- 이름 기준 파라미터는 앞에 :를 사용함
```java
String usernameParam = "User1";
        
TypedQuery<Member> query = 
        em.createQuery("SELECT m FROM member m where m.username = :username", Member.class);
        
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();

```
- :username이라는 이름 기준 파라미터 정의
- query.setParameter() 에서 username이라는 이름으로 파라미터를 바인딩
- 참고) JPQL API는 대부분 메소드 체인 방식으로 설계 - 연속해서 작성가능
#### 위치 기준 파라미터
```java
List<Member> resultList = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
        .setParameter(1, usernameParam)
        .getResultList();
```
- 위치 기준 파라미터를 사용하려면 '?' 다음에 위치 값을 주면 됨
    - 위치 값은 1부터 시작

- 위치 기준 파라미터 방식보다는 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확함

### 10.2.3 프로젝션
- SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라 한다.
    - (SELECT (프로젝션 대상) FROM)으로 대상을 선택
- 프로젝션 대상
    - 엔티티
    - 엠비디드 타입
    - 스칼라 타입 (숫자, 문자 등 기본 데이터 타입)

🔽 엔티티 프로젝션
```java
SELECT m FROM Member m          //회원
SELECT m.team FROM Member m     //팀
```
- 컬럼을 하나하나 나열해서 조회해야 하는 SQL과 차이가 있음
- 이렇게 조회한 엔티티는 영속성 컨텍스트에서 관리됨


🔽 임베디드 타입 프로젝션
```java
String query = "SELECT a FROM Address a";
```
- 잘못된 쿼리
- 임베디드 타입은 조회의 시작점이 될 수 없음
- 위 코드는 Address(Order의 객체타입)를 조회의 시작점으로 사용함

```java
String query = "SELECT o.address FROM Order o";
List<Address> address = em.createQuery(query, Address.class)
                            .getResultList();
```
- Order 엔티티가 시작점.
- 엔티티를 통해 임베디드 타입을 조회할 수 있음

👉 실행된 SQL
```h2
select
    order.city,
    order.street,
    order.zipcode
from
    Orders order
```
- 임베디드 타입은 엔티티 타입이 아닌 값 타입.
- 이렇게 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.

🔽 스칼라 타입 프로젝션
```java
List<String> username = 
        em.createQuery("SELECT m.username FROM Member m", String.class)
        .getResultList();
```
- 👆 전체 회원의 이름 조회
- 숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라 함

```java
SELECT DISTINCT username FROM Member m
```
- 중복 데이터 제거시 DISTINCT 사용

```java
Double orderAmountAvg =
        em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
        .getSingleResult();
```
- 위와 같은 통계 쿼리도 주로 스칼라 타입으로 조회

🔽 여러 값 조회
- 꼭 필요한 데이터들만 선택해서 조회해야 할 때 사용
- 프로젝션에 여러 값을 선택하면 TypeQuery를 사용할 수 없고 Query 사용

```java
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

Iterator iterator = resultList.iterator();
while (iterator.hasNext()) {
    Object[] row = (Object[]) iterator.next();
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```
- 제네릭에 Object[] 사용 시 코드 간결해짐
```java
List<Object[]> resultList = 
        em.createQuery("SELECT m.username, m.age FROM Member m")
        .getResultList();

for (Object[] row : resultList){
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```
- 엔티티 타입도 여러 값을 함께 조회할 수 있음
```java
List<Object[]> resultList = 
        em.createQuery("SELECT o.member, o.product, o.orderAmount From Order o")
        .getResultList();
        
for(Object[] row : resultList) {
    Member member = (Member) row[0];    //엔티티
    Product product = (Product) row[1]; //엔티티
    int orderAmount = (Integer) row[2]; //스칼라
}
```
- 물론 이때도 조회한 엔티티는 영속성 컨텍스트에서 관리함

🔽 NEW 명령어
```java
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m").getResultList();
        
//객체 변환 작업
List<UserDTO> userDTOs = new ArrayList<UserDTO>();
for (Object[] row : resultList) {
    UserDTO userDTO = new UserDTO((String)row[0], (Integer)row[1]);
    userDTOs.add(userDTO);
}
return userDTOs;
```
```java
public class UserDTO {
    
    private String username;
    private int age;
    
    public UserDTO(String username, int age) {
        this.username = username;
        this.age = age;
    }
    
    //...
}
```
- username, age 두 필드를 프로젝션해서 타입을 지정할 수 없다면 TypeQuery를 사용할 수 없음.
- 따라서 TypeQuery 사용 불가
    - Object[] 반환받음
- 실제 애플리케이션 개발시 Object[] 직접 사용 X
    - UserDTO처럼 의미 있는 객체로 변환 후 사용

- 위와 같은 객체 변환 작업은 불편 -> NEW 명령어 사용하기
```java
TypedQuery<UserDTO> query = 
    em.createQuery("SELECT new com.hasun.study.domain.member.UserDTO(m.username, m.age)
    FROM Member m", UserDTO.class);
        
List<UserDTO> resultList = query.getResultList();
```
- SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정할 수 있다.
    - 이 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있음
- NEW 명령어를 사용한 클래스로 TypeQuery 사용할 수 있음

❗ 주의
1. 패키지 명을 포함한 전체 클래스 명을 입력
2. 순서와 타입이 일치하는 생성자 필요

### 10.2.4 페이징 API
- 페이징을 처리하는 SQL 문법이 데이터베이스마다 다른 문제를 JPQL을 사용하여 해결할 수 있음
- JPA는 페이징을 다음 두 API로 추상화했음
    - setFirstReulst(int startPostition): 조회 시작 위치 (0부터 시작)
    - setMaxResults(int maxResult): 조회할 데이터 수

```java
TypedQuery<Member> query = 
        em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", 
        Member.class);
        
query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```
- 10번 부터 시작해서 총 20건의 데이터 조회
    - 11~30번 데이터 조회

### 10.2.5 집합과 정렬
p367 ~ 369 참고

### 10.2.6 JPQL 조인
#### 내부 조인
- 내부 조인은 INNER JOIN을 사용함 (INNER 생략가능)
```java
String teamName = "팀A";
String query = "SELECT m FROM Member m INNER JOIN m.team t " +
                "WHERE t.name = :teamName";
        
List<Member> members = em.createQuery(query, Member.class)
      .setParameter("teamName", teamName)
      .getResultList();
```
- 생성된 내부 조인 SQL
```h2
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
WHERE
    T.NAME=?
```
- JPQL 조인의 가장 큰 특징 -> 연관 필드를 사용한다는 것
- 위 코드에서 m.team이 연관 필드
    - 연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드를 말함

- FROM Member m - 회원을 선택하고 m 이라는 별칭을 줌
- Member m JOIN m.team t - 회원이 가지고 있는 연관 필드로 팀과 조인함. 조인한 팀에는 t라는 별칭을 줌
- 참고) JPQL 조인을 아래와 같이 SQL 조인처럼 사용하면 문법 오류 발생
    - JPQL은 JOIN 명령어 다음에 조인할 객체의 연관 필드를 사용함
```java
FROM Member m JOIN Team t   //잘못된 JPQL 조인, 오류!
```

- 조인 결과 활용
```jpaql
SELECT m.username, t.name
FROM Member m JOIN m.team t
WHERE t.name = '팀A'
ORDER BY m.age DESC
```
- 쿼리는 '팀A'소속인 회원을 나이 내림차순으로 정렬 -> 회원명과 팀명을 조회함
- 만약 조인한 두 개의 엔티티를 조회하려며 다음과 같이 JPQL을 작성

```jpaql
SELECT m, t
FROM Member m JOIN m.team t
```

- 서로 다른 타입의 두 엔티티를 조회했으므로 TypeQuery를 사용할 수 없음
- 따라서 다음처럼 조회해야 함

```java
String query = "SELECT m, t FROM Member m JOIN m.team t";
List<Object[]> result = em.createQuery(query).getResultList();

for(Object[] row : result) {
    Member member = (Member) row[0];
    Team team = (Team) row[1];
}
```

#### 외부 조인
```jpaql
SELECT m
FROM Member m LEFT [OUTER] JOIN m.team t
```
- 외부 조인은 기능상 SQL의 외부 조인과 같음
- OUTER는 생략 가능해서 보통 LEFT JOIN으로 사용함

#### 컬렉션 조인
- 일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것
- [회원 -> 팀]으로의 조인은 다대일 조인이면서 단일 값 연관 필드(m.team)를 사용
- [팀 -> 회원]은 반대로 일대다 조인이면서 컬렉션 값 연관 필드(m.members)를 사용

```jpaql
SELECT t, m FROM Team t LEFT JOIN t.members m
```
- 여기서 t LEFT JOIN t.members는 팀과 팀이 보유한 회원목록을 컬렉션 값 연관 필드로 외부 조인했다.

#### 세타 조인
- WHERE 절을 사용해서 세타 조인을 할 수 있음
- 참고로 세타 조인은 내부 조인만 지원함.
- 세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있음

```jpaql
//회원 이름이 팀 이름과 똑같은 사람 수를 구하는 예
//JPQL
select count (m) from Member m, Team t
where m.username = t.name

//SQL
SELECT COUNT(M.ID)
FROM
    MEMBER M CROSS JOIN TEAM T
WHERE
    M.USERNAME=T.NAME    
```

#### JOIN ON 절(JPA 2.1)
- ON 절을 사용하면 조인 대상을 필터링하고 조인할 수 있음
- 참고로 내부 조인의 ON 절은 WHERE 절을 사용할 떄와 결과가 같으므로 보통 ON 절은 외부 조인에서만 사용함

```jpaql
//JPQL
select m, t from Member m
left join m.team t on t.name = 'A'

//SQL
SELECT m.*, t.* FROM Member m
LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name='A'
```
- 모든 회원을 조회하면서 회원과 연관된 팀도 조회, 이때 팀은 이름이 'A'인 팀만 조회


### 10.2.7 페치 조인
- 페치 조인은 SQL에서 이야기하는 조인의 종류 X
- JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
- join fetch 명령어로 사용
```jpaql
페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로
```

#### 엔티티 페치 조인
- 페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하는 JPQL
```jpaql
select m
from Member m join fetch m.team
```
- 이렇게 하면 연관된 엔티티나 컬렉션을 함께 조회함
- 여기선 회원(m)과 팀(m.team)을 함께 조회
- 페치 조인은 별칭을 사용할 수 없다.

- 실행된 SQL
```h2
SELECT
    M.*, T.*
FROM MEMBER T
INNER JOIN TEAM T ON M.TEAM_ID=T.ID
```


![img.png](img/엔티티_페치_조인시도.png)
![img_1.png](img/엔티티_페치_조인_결과_테이블.png)
![img_2.png](img/엔티티_페치_조인_결과_객체.png)

- 엔티티 페치 조인 JPQL에서 select m으로 회원 엔티티만 선택했는데
  실행된 SQL에서는 SELECT M.* T.*로 회원과 연관된 팀도 함께 조회함.

- 그림 10.5 에서는 회원과 팀 객체가 객체 그래프를 유지하면서 조회된 것을 확인할 수 있음.
```java
String jpql = "select m from Member m join fetch m.team";
        
List<Member> members = em.createQuery(jpql, Member.class).getResultList();
        
for (Member member : members) {
    //페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩 발생 안함
    System.out.println("username = "+member.getUsername()+", " +
}
```
- 출력 결과
```java
username = 회원1, teamname = 팀A
username = 회원2, teamname = 팀A
username = 회원3, teamname = 팀B
```

#### 컬렉션 페치 조인
- 일대다 관계인 컬렉션을 페치 조인해보자
```jpaql
select t
from Team t join fetch t.members
where t.name = '팀A'
```
- 팀(t)을 조회하면서 페치 조인을 사용해서 연관된 회원 컬렉션(t.members)도 함께 조회함
```h2
SELECT T.*, M.*
FROM TEAM T 
INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
WHERE T.NAME = '팀A'
```
![img_3.png](img/컬렉션_페치_조인_시도.png)
![img_4.png](img/컬렉션_페치_조인_결과_테이블.png)
![img_5.png](img/컬렉션_페치_조인_결과_객체.png)

- 컬렉션을 페치 조인한 JPQL에서 select t로 팀만 선택했는데 예제의 실행된 SQL을 보면
  T.*. M.*로 팀과 연관된 회원도 함께 조회한 것을 확인할 수 있음.

- 또 그림 10.6의 TEAM 테이블에서 '팀A'는 하나지만 MEMBER테이블과 조인하면서
  결과가 증가하여 그림 10.7의 조인 결과 테이블을 보면 같은 '팀A'가 2건 조회되었음

- 따라서 그림 10.8의 컬렉션 패치 조인 결과 객체에서 teams 결과 예제를 보면 주소가 0x100으로 같은 '팀A'를 2건 가지게 됨
```java
String jpql = "select t from Team t join fetch t.members where t.name = '팀A'";
List<Team> teams = em.createQuery(jpql, Team.class).getResultList();
        
for (Team team : teams) {

System.out.println("teamname = "+team.getName() + ", team = "+team);
            
    for (Member member : team.getMember()) {
                    
    //페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안 함
    System.out.println("->username = "+member.getUsername()+", member = "+member);
    }
}
```

- 출력 결과
```java
teamname = 팀A, team = Team@0x100
->username = 회원1, member = Member@0x200
->username = 회원2, member = Member@0x300
teamname = 팀A, team = Team@0x100
->username = 회원1, member = Member@0x200
->username = 회원2, member = Member@0x300
```
- 출력 결과를 보면 같은 '팀A'가 2건 조회된 것을 확인할 수 있다.

#### 페치 조인과 DISTINCT
- DISTINCT는 중복된 결과를 제거하는 명령
- JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론이고 애플리케이션에서 한 번 더 중복을 제거함
```jpaql
select distinct t 
from Team t join fetch t.members
where t.name = '팀A'
```
- 먼저 DISTINCT를 사용하면 SQL에 SELECT DISTINCT가 추가됨
- 하지만 지금은 각 로우의 데이터가 다르므로 SQL의 DISTINCT는 효과가 없음
- 다음으로 애플리케이션에서 distinct 명령어를 보고 중복된 데이터를 걸러냄
- select distinct t의 의미는 팀 엔티티의 중복을 제거하라는 것.
- 따라서 중복인 팀A는 하나만 조회된다.

![img_6.png](img/페치_조인_DISTINCT_결과.png)


#### 페치 조인의 특징과 한계
- 페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화할 수 있음
- 다음처럼 엔티티에 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부름
- 페치 조인은 글로벌 로딩 전략보다 우선함
- 예를 들어 글로벌 로딩 전략을 지연 로딩으로 설정해도 JPQL에서 페치 조인을 사용하면 페치 조인을 적용해서 함께 조회함
```java
@OneToMany(fetch = FetchType.LAZY)  //글로벌 로딩 전략
```

- 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어남.
- 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로
  성능에 악영향을 미칠 수 있음
    - 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용
    - 최적화가 필요하면 페치 조인을 적용하는 것이 효과적

- 또한 페치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회하므로
  지연 로딩이 발생하지 않음
    - 따라서 준영속 상태에서도 객체 그래프를 탐색할 수 있음

#### 페치 조인의 한계
- 페치 조인 대상에는 별칭을 줄 수 없다
- 둘 이상의 컬렉션을 페치할 수 없다
- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다

- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 한다면?
    - 억지로 페치 조인을 사용하기보다는 여러 테이블에서 필요한 필드들만 조회해서 DTO로 반환하는 것이 더 효과적임.
  

### 10.2.8 경로 표현식
- .(점)을 찍어 객체 그래프를 탐색하는 것
```jpaql
select m.username
from Member m
    join m.team t
    join m.orders o
where t.name = '팀A'    
```
- m.username, m.team, m.orders, t.name 이 경로 표현식이다.

#### 경로 표현식의 용어 정리
- 상태 필드 : 값을 저장하기 위한 필드 (필드 or 프로퍼티)
- 연관 필드 : 연관관계를 위한 필드, 임베디드 타입 포함 (필드 or 프로퍼티)
  - 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티
  - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션
  
#### 경로 표현식과 특징
- JPQL에서 경로 표현식을 사용하여 경로 탐색을 하려면 다음 3가지 경로에 따라
어떤 특징이 있는지 이해해야 함
  - 상태 필드 경로: 경로 탐색의 끝. 더는 탐색할 수 없음
      - 예) select m.username, m.age from Member m
        - m.username, m.age -> 상태 필드 경로 탐색
  - 단일 값 연관 경로: 묵시적으로 내부 조인이 일어남. 단일 값 연관 경로는 계속 탐색 가능
  - 컬렉션 값 연관 경로: 묵시적으로 내부 조인이 일어남. 더는 탐색할 수 없음.
    - 단 FROM 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색 가능
  
#### 단일 값 연관 경로 탐색
- select o.member from Order o
  - JPQL을 실행한 결과 >
```sql
select m.* 
from Orders o
    inner join Member m on o.member_id = m.id
```
- 묵시적 조인
  - 위와 같이 단일 값 연관 필드로 경로 탐색을 할 시 SQL에서 내부 조인이 일어남
    - 예) select m.team from Member m
- 명시적 조인
  - JOIN을 직접 적어주는 것
    - 예) select m from Member m Join m.team t
  
```jpaql
select o.member.team
from Order o
where o.product.name = 'productA' and o.address.city = 'JINJU'
```
- 주문 중에서 상품명이 'productA', 배송지가 'JINJU'인 회원이 소속된 팀을 조회하는 예시

🔽 실행된 SQL
```sql
select t.*
from Orders o
inner join Member m on o.member_id = m.id
inner join Team t on o.team_id = t.id
inner join Product p on o.product_id = p.id
where p.name = 'productA' and o.city = 'JINJU'
```  

#### 컬렉션 값 연관 경로 탐색
```jpaql
select t.members from Team t; //성공
select t.members.username from Team t; //실패
```
- 컬렉션까지는 경로 탐색이 가능하나, 아래 실패 코드 처럼
컬렉션에서 경로 탐색을 시작하는 것은 허락하지 않음.
  
- 컬렉션에서 경로 탐색이 필요하다면?
```jpaql
select m.username from Team t join t.members m
```
- 조인을 사용하여 새로운 별칭을 획득해야 함

- 참고) 컬렉션은 컬렉션의 크기를 구할 수 있는 size라는 기능 사용 가능
  - size -> COUNT 함수 SQL로 변환
```jpaql
select t.members.size from Team t
```  

#### 경로 탐색을 사용한 묵시적 조인 시 주의사항
- 항상 내부 조인임
- 컬렉션은 경로 탐색의 끝. 컬렉션에서 경로 탐색을 하기 위해선 명시적으로 조인해서 별칭을 얻어야 함
- 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM 절에 영향을 줌

- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움
- 성능이 중요하면 분석하기 쉽도록 묵시적 조인보다는 명시적 조인을 사용하자


### 10.2.9 서브쿼리
- JPQL의 서브쿼리는 WHERE, HAVING 절에서만 사용이 가능함
- FROM 절에서는 사용할 수 없다.

🔽 EXITS
- 문법 👉 [NOT] EXISTS (subquery)
- 서브쿼리에 결과가 존재하면 참. NOT은 반대
- 예) 팀A 소속인 회원
```jpaql
select m from Member m
where exists (select t from m.team t where t.name = '팀A')
```

🔽 {ALL | ANY | SOME}
- 문법 👉 {ALL | ANY | SOME} (subquery)
- 비교 연산자와 같이 사용 {= | > | >= | < | <= | <>}
  - ALL: 조건을 모두 만족하면 참
  - ANY or SOME: 둘은 같은 의미. 조건을 하나라도 만족하면 참
- 예) 전체 상품 각각의 재고보다 주문량이 많은 주문들
```jpaql
select o from Order o
where o.orderAmount > ALL (select p.stockAmount from Product p)
```
- 예) 어떤 팀이든 팀에 소속된 회원
```jpaql
select m from Member m
where m.team = ANY (select t from Team t)
```

🔽 IN
- 문법 👉 [NOT] IN (subquery)
- 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참.
- 참고) 서브쿼리가 아닌 곳에서도 사용됨
- 예) 20세 이상을 보유한 팀
```jpaql
select t from Team t
where t IN (select t2 From Team t2 JOIN t2.members m2 where m2.age >= 20)
```


### 10.2.10 조건식
- 연산자 우선 순위
- 논리 연산과 비교식
- Between, IN, Like, NULL 비교
- 컬렉션 식
- 스칼라 식
- CASE 식
p.388 ~ p.396

### 10.2.11 다형성 쿼리
- JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회
```java
List resultList = em.createQuery("select i from Item i").getResultList();
```
- 단일 테이블 전략 사용 시 실행된 SQL
```sql
SELECT * FROM ITEM
```
- 조인 전략 사용 시 실행된 SQL
```sql
SELECT
    i.ITEM_ID, i.DTYPE, i.name, i.price, i.stockQuantity,
    b.author, b.isbn,
    a.artist, a.etc,
    m.actor, m.director
FROM
    Item i
left outer join
    Book b on i.ITEM_ID=b.ITEM_ID
left outer join
    Album a on i.ITEM_ID=a.ITEM_ID
left outer join
    MOVIE m on i.ITEM_ID=m.ITEM_ID
```

#### TYPE
- 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용
- 예) Item 중에 Book, Movie 조회
```jpaql
//JPQL
select i from Item i
where type(i) IN (Book, Movie)
```
```sql
//SQL
SELECT i FROM Item i
WHERE i.DTYPE in ('B', 'N')
```

#### TREAT(JPA 2.1)
- 자바의 타입 캐스팅과 비슷
- 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
- JPA 표준은 FROM , WHERE절에서 사용할 수 있지만,
하이버네이트는 SELECT 절에서도 TREAT 사용가능
  
- 예) 부모인 Item 자식인 Book
```jpaql
//JPQL
select i from Item i where treat(i as Book).author = 'kim'
```
```sql
//SQL
select i.* from Item i
where
    i.DTYPE = 'B'
    and i.author = 'kim'
```

### 10.2.12 사용자 정의 함수 호출
- 문법 👉 function_invocation::= FUNCTION(function_name (, function_arg)*)
- 예) select function("group_concat", i.name) from Item i

- 하이버네이트 구현체를 사용하려면 방언 클래스를 상속해서 구현하고
사용할 데이터베이스 함수를 미리 등록해야 함
  
- p.398 - 399 참고

### 10.2.13 기타 정리
- enum은 = 비교 연산만 지원
- 임베디드 타입은 비교 지원 X

#### EMPTY STRING
- 데이터베이스에 따라 '' -> NULL 혹은 길이 0인 Empty String

#### NULL 정의
- 조건을 만족하는 데이터가 하나도 없음
- NULL과의 모든 수학적 계산 결과는 NULL
- Null == Null -> 알 수 없는 값
- Null is Null -> 참

### 10.2.14 엔티티 직접 사용
#### 기본 키 값
- 객체 인스턴스 : 참조 값으로 식별
- 테이블 로우 : 기본 키 값으로 식별
- JPQL에서 엔티티 객체를 직접 사용하면 SQL에서는 해당 엔티티의 기본 키값을 사용
```sql
select count(m.id) from Member m    //엔티티의 아이디를 사용
select count(m) from Member m       //엔티티를 직접 사용
```
- 엔티티 직접 사용 시 JPQL-> SQL 변환 과정에서 엔티티의 기본 키를 사용함
- 따라서 실제 실행된 SQL은 둘 다 같음

### 10.2.15 Named 쿼리: 정적 쿼리
- 동적 쿼리: em.createQuery("select ..") -> JPQL을 문자로 완성해서 넘기는 것
- 정적 쿼리: 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용가능 (Named 쿼리)

```java
@Entity
@NamedQuery(
        name = "Member.findByUsername",
        query = "select m from Member m where m.username = :username"
)
public class Member { ... }
```
- Named 쿼리 사용
```java
List<Member> resultList = em.createNamedQuery("Member.findByUsername",
        Member.class)
                .setParameter("username", "회원1")
                .getResultList();
```
- 2개 이상의 Named 쿼리
```java
@NamedQueries({
        @NamedQuery(
                name = "Member.findByUsername",
                query = "select m from Member m where m.username = :username"),
        @NamedQuery(
                name = "Member.count",
                query = "select count(m) from Member m")
})
```

## 10.3 Criteria
- JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API
- Criteria를 사용하면 문자가 아닌 코드로 JPQL을 작성한다.
  - 문법 오류를 컴파일 단계에서 잡을 수 있음.
  - 문자 기반의 JPQL보다 동적 쿼리를 안전하게 생성할 수 있음.
  
- Criteria의 단점
  - 코드가 복잡하고 장황해서 직관적으로 이해가 힘들다.
  

### 10.3.1 Criteria 기초
```java
//JPQL: select m from Member m

CriteriaBuilder cb = em.getCriteriaBuilder();   //1. Criteria 쿼리 빌더

//2. Criteria 생성, 변환 타입 지정
CriteriaQuery<Member> cq = cb.createQuery(Member.class);

Root<Member> m = cq.from(Member.class);     //3. FROM 절
cq.select(m);   //4. SELECT 절

TypedQuery<Member> query = em.createQuery(cq);
List<Member> members = query.getResultList();
```
- 모든 회원 엔티티를 조회하는 JPQL을 Criteria로 작성한 코드이다.
1. Criteria 쿼리를 생성하려면 먼저 Criteria 빌더(CriteriaBuilder)를 얻어야 함
  - Criteria 빌더는 EntityManager나 EntityManagerFactory에서 얻을 수 있음
2. Criteria 쿼리 빌더에서 Criteria 쿼리를 생성한다. 이때 반환타입을 지정할 수 있다.
3. From 절을 생성함
  - 반환된 값 m은 Criteria에서 사용하는 특별한 별칭임.
  - m을 조회의 시작점이라는 의미로 쿼리 루트라 한다.
4. SELECT 절을 생성한다.

이 과정을 통해 Criteria 쿼리를 완성하고 나면 다음 순서는 JPQL과 같음.
em.createQuery(cq)에 완성된 Criteria 쿼리를 넣어주면 된다.

- 검색 조건과 정렬을 추가 한 예제
```java
CriteriaBuilder cb = em.getCriteriaBuilder();
        
CriteriaQuery<Member> cq = cb.createQuery(Member.class);
Root<Member> m = cq.from(Member.class); //FROM 절 생성
        
//1. 검색 조건 정의
Predicate usernameEqual = cb.equal(m.get("username"), "회원1");
        
//2. 정렬 조건 정의
Order ageDesc = cb.desc(m.get("age"));
        
//3. 쿼리 생성
cq.select(m)
    .where(usernameEqual)   //WHERE 절 생성
    .orderBy(ageDesc);      //ORDER BY 절 생성
        
List<Member> resultList = em.createQuery(cq).getResultList();
```

1. 검색 조건을 정의한 부분을 보면 m.get("username")으로 되어 있는데 m은 회원 엔티티의 별칭임.
  - JPQL의 m.username과 같은 표현.
  - cb.equal(A, B)는 이름 그대로 A = B 라는 뜻.
  - cb.equal(m.get("username"), "회원1") = (JPQL) m.username = '회원1'

2. 정렬 조건을 정의하는 코드인 cb.desc(m.get("age")) = (JPQL) m.age desc
3. 만들어둔 조건을 where, orderBy 에 넣어서 원하는 쿼리를 생성한다.

- Criteria는 검색 조건부터 정렬까지 Criteria 빌더(CriteriaBuilder)를 사용해서 코드를 완성함

✨ 쿼리 루트(Query Root)와 별칭
- Root<Member> m = cq.from(Member.class); 여기서 m이 쿼리 루트이다.
- 쿼리 루트는 조회의 시작점이다.
- Criteria에서 사용되는 특별한 별칭임. JPQL의 별칭이라 생각하면 된다.
- 별칭은 엔티티에만 부여할 수 있다.

✨ Criteria의 경로 표현식
- m.get("username") -> (JPQL) m.username
- m.get("team").get("name") -> (JPQL) m.team.name

#### 10살을 조과하는 회원을 조회하고 나이 역순으로 정렬하는 예제
```java
//select m from Member m
//where m.age > 10 order by m.age desc;

Root<Member> m = cq.from(Member.class);

//타입 정보 필요
Predicate ageGt = cb.greaterThan(m.<Integer>get("age"), 10);

cq.select(m);
cq.where(ageGt);
cq.orderBy(cb.desc(m.get("age")));
```

- cb.greaterThan(m.<Integer>get("age"), 10)
  - A > B
  - m.<Integer>get("age") 왜 제네릭으로 타입 정보를 주었을까?
    - m.get("age")는 "age"의 타입 정보를 알지 못한다.
    - 따라서 제네릭으로 반환 타입 정보를 명시해야 함
    - (보통 String 같은 문자 타입은 지정하지 않아도 된다.)
  - greaterThan() = gt()
  
### 10.3.2 Criteria 쿼리 생성
- Criteria를 생성하려면 CriteriaBuilder.createQuery() 메소드로 Criteria 쿼리를 생성한다.
- Criteria 쿼리를 생성할 때 파라미터로 쿼리 결과에 대한 반환 타입을 지정할 수 있다.
  - CriteriaQuery를 생성할때 Member.class를 반환타입으로 지정하면
  em.createQuery(cq)에서 반환 타입을 지정하지 않아도 된다.
```java
CriteriaBuilder cb = em.getCriteriaBuilder();

//Member를 반환타입으로 지정
CriteriaQuery<Member> cq = cb.createQuery(Member.class);
//...
        
//위에서 Member를 타입으로 지정했으므로 지정하지 않아도 Member 타입을 반환
List<Member> resultList = em.createQuery(cq).getResultList();
```    

- 반환 타입을 지정할 수 없거나 반환 타입이 둘 이상이면 아래와 같이 타입을 지정하지 않고 Object로 반환받으면 된다.
```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Object> cq = cb.createQuery();        //조회값 반환 타입: Object
//...
List<Object> resultList = em.createQuery(cq).getResultList();
```

- 반환 타입이 둘 이상이면 Object[]를 사용하는 것이 편리함.
```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
//...
List<Object[]> resultList = em.createQuery(cq).getResultList();
```

- 반환 타입을 튜플로 받고 싶으면 튜플을 사용한다.
```java
CriteriaBuilder cb = em.getCriteriaBuilder();

//조회값 반환 타입: Turple
CriteriaQuery<Tuple> cq = cb.createTupleQuery();
//...
TypedQuery<Tuple> query = em.createQuery(cq);
```


### 10.3.3 조회
```java
public interface CriteriaQuery<T> extends AbstractQuery<T> {

    //한 건 지정
    CriteriaQuery<T> select(Selection<? extends T> selection);
    
    //여러 건 지정
    CriteriaQuery<T> multiselect(Selection<?>... selections);
    
    //여러 건 지정
    CriteriaQuery<T> multiselect(List<Selection<?>> selectionList);
}
```

#### 조회 대상을 한 건, 여러 건 지정
select에 조회 대상을 하나만 지정
```java
cq.select(m) //JPQL select m
```
조회 대상을 여러 건을 지정하려면 multiselect를 사용
```java
//JPQL: select m.username, m.age
cq.multiselect(m.get("username"), m.get("age"))
```
여러 건 지정은 다음처럼 cb.array를 사용해도 된다.
```java
CriteriaBuilder cb = em.getCriteriaBuilder();
//JPQL: select m.username, m.age
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
Root<Member> m = cq.from(Member.class);
cq.select(cb.array(m.get("username"), m.get("age")));
```

#### DISTINCT
distinct는 select, multiselect 다음에 distinct(true)를 사용하면 됨
```java
//JPQL: select distinct m.username, m.age
cq.multiselect(m.get("username"), m.get("age")).distinct(true);
```

- 위 설명들을 적용시킨 코드
```java
//JPQL: select distinct m.username, m.age from Member m
        
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
Root<Member> m = cq.from(Member.class);
cq.multiselect(m.get("username"), m.get("age")).distinct(true);
//cq.select(cb.array(m.get("username"), m.get("age"))).distinct(true); //위 코드와 같다.
        
TypedQuery<Object[]> query = em.createQuery(cq);
List<Object[]> resultList = query.getResultList();
```

#### NEW, construct()
JPQL에서 select new 생성자() 구문을 Criteria에서는 cb.construct(클래스 타입, ...)로 사용함
```java
<Y> CompoundSelection<Y> construct(Class<Y> resultClass, Selection<?>... selections);
```

construct()를 사용한 예제
```java
//JPQL: select new hasun.domain.MemberDTO(m.username, m.age)
//from Member m

CriteriaQuery<MemberDTO> cq = cb.createQuery(MemberDTO.class);
Root<Member> m = cq.from(Member.class);

cq.select(cb.construct(MemberDTO.class, m.get("username"), m.get("age")));

TypedQuery<MemberDTO> query = em.createQuery(cq);
List<MemberDTO> resultList = query.getResultList();
```
- JPQL에서는 select new hasun.domain.MemberDTO()처럼 패키지명을 다 적음.
- Criteria는 코드를 직접 다루기 때문에 MemberDTO.class처럼 간략하게 사용할 수 있다.

#### 튜플
Criteria는 Map과 비슷한 튜플이라는 특별한 반환 객체를 제공한다.

```java
//JPQL: select m.username, m.age from Member m

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Tuple> cq = cb.createTupleQuery();
//CriteriaQuery<Tuple> cq = cb.createQuery(Tuple.class); //위와 같다
        
Root<Member> m = cq.from(Member.class);
cq.multiselect(
        m.get("username").alias("username"),    //튜플에서 사용할 튜플 별칭
        m.get("age").alias("age")
);

TypedQuery<Tuple> query = em.createQuery(cq);
List<Tuple> resultList = query.getResultList();
for (Tuple tuple : resultList) {
    //튜플 명칭으로 조회
    String username = tuple.get("username", String.class);
    Integer age = tuple.get("age", Integer.class);
}
```
튜플을 사용하려면 cb.createTypleQuery() 또는 cb.createQuery(Tuple.class)로 Criteria를 생성함
1. 튜플은 튜플의 검색 키로 사용할 튜플 전용 별칭을 필수로 할당해야 한다.
  - 별칭은 alias()메소드를 사용해서 지정할 수 있다.
2. 선언해둔 튜플 별칭으로 데이터를 조회할 수 있다.

- 튜플은 이름 기반이므로 순서 기반의 Object[]보다 안전함
- tuple.getElements() 같은 메소드를 사용해서 현재 튜플의 별칭과 자바 타입도 조회할 수 있다.

📌 참고) 튜플에 별칭을 준다고 해서 실제 SQL에 별칭이 달리는 것은 아님. 튜플은 Map과 비슷한 구조여서 별칭을 키로 사용함.

- 튜플은 엔티티도 조회할 수 있다. 튜플을 사용할 때는 별칭을 필수로 주어야 하는 것에 주의
```java
CriteriaBuilder cb = em.getCriteriaBuilder();

CriteriaQuery<Tuple> cq = cb.createTupleQuery();
Root<Member> m = cq.from(Member.class);
cq.select(cb.tuple(
        m.alias("m"),   //회원 엔티티, 별칭 m
        m.get("username").alias("uesrname") //단순 값 조회, 별칭 username
));

TypedQuery<Tuple> query = em.createQuery(cq);
List<Tuple> resultList = query.getResultList();
for (Tuple tuple : resultList) {
    Member member = tuple.get("m", Member.class);
    String username = tuple.get("username", String.class);
}
```
- cq.select(cb.tuple(...)) = cq.multiselect(...)

### 10.3.4 집합
#### GROUP BY
- 팀 이름별로 나이가 가장 많은 사람과 가장 적은 사람을 구하는 예제
```java
/*
    JPQL:
    select m.team.name, max(m.age), min(m.age)
    from Member m
    group by m.team.name
*/        

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
Root<Member> m = cq.from(Member.class);

Expression maxAge = cb.max(m.<Integer>get("age"));
Expression minAge = cb.min(m.<Integer>get("age"));

cq.multiselect(m.get("team").get("name"), maxAge, minAge);
cq.groupBy(m.get("team").get("name"));  //GROUP BY
        
TypedQuery<Object[]> query = em.createQuery(cq);
List<Object[]> resultList = query.getResultList();
```
- cq.groupBy(m.get("team").get("name")) = (JPQL) group by m.team.name

#### HAVING
- 팀에 가장 나이 어린 사람이 10살을 초과하는 팀을 조회한다는 조건을 추가
```java
cq.multiselect(m.get("team").get("name"), maxAge, minAge)
    .groupBy(m.get("team").get("name"))
    .having(cb.gt(minAge, 10));  //HAVING
```
- having(cb.gt(minAge, 10)) = (JPQL) having min(m.age) > 10

### 10.3.5 정렬
- 정렬 조건도 Criteria 빌더를 통해 생성
- cb.desc(...) 또는 cb.asc(...)로 생성
```java
cq.select(m)
    .where(ageGt)
    .orderBy(cb.desc(m.get("age"))); //JPQL: order by m.age desc
```

### 10.3.6 조인
- 조인은 join() 메소드와 JoinType 클래스를 사용함
```java
/*
    JPQL:
    select m, t from Member m
    inner join m.team t
    where t.name = '팀A'
*/
        
Root<Member> m = cq.from(Member.class);
Join<Member, Team> t = m.join("team", JoinType.INNER);  //내부 조인
        
cq.multiselect(m, t)
    .where(cb.equal(t.get("name"), "팀A"))        

```
- 쿼리 루트(m)에서 바로 m.join("team") 메소드를 사용해서 회원과 팀을 조인했다.
- 그리고 조인한 team에 t라는 별칭을 주었다.
- 여기서는 JoinType.INNER를 설정해서 내부 조인을 사용했다.
- 참고) 조인 타입을 생략하면 내부 조인을 사용함.

```java
m.join("team")  //내부조인
m.join("team", JoinType.INNER) //내부 조인
m.join("team", JoinType.LEFT) //외부 조인
```

FETCH JOIN은 다음 같이 사용함
```java
Root<Member> m = cq.from(Member.class);
m.fetch("team", JoinType.LEFT);

cq.select(m);
```
페치 조인은 fetch(조인대상, JoinType)을 사용함. 페치 조인 시 주의사항은 JPQL과 같다.

### 10.3.7 서브 쿼리
- 간단한 서브 쿼리
  - 메인 쿼리와 서브 쿼리 간에 관련이 없는 단순한 서브 쿼리
  - 평균 나이 이상의 회원을 구하는 서브 쿼리 예제
```java
/*
    JPQL:
    select m. from Member m
    where m.age >=
        (select AVG(m2.age) from Member m2)
*/
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> mainQuery = cb.createQuery(Member.class);

//서브 쿼리 생성
Subquery<Double> subQuery = mainQuery.subquery(Double.class);
Root<Member> m2 = subQuery.from(Member.class);
subQuery.select(cb.avg(m2.<Integer>get("age")));

//메인 쿼리 생성
Root<Member> m = mainQuery.from(Member.class);
mainQuery.select(m).where(cb.ge(m.<Integer>get("age"), subQuery));
```  
1. 서브 쿼리 생성 부분을 보면 서브 쿼리는 mainQuery.subquery(...)로 생성
2. 메인 쿼리 생성 부분을 보면 where(... subQuery)에서 생성한 서브 쿼리를 사용한다.

- 상호 관련 서브 쿼리
  - 메인 쿼리와 서브 쿼리 간에 서로 관련이 있을 때 Criteria를 어떻게 작성하는지 알아보자.
  - 서브 쿼리에서 메인 쿼리의 정보를 사용하려면 메인 쿼리에서 사용한 별칭을 얻어야 함.
  - 서브 쿼리는 메인 쿼리의 Root Join을 통해 생성된 별칭을 받아 다음과 같이 사용함
  
```java
.where(cb.equal(subM.get("username"), m.get("username")));
```

- 팀A에 소속된 회원을 찾는 예제
- 조인으로 해결하는 것이 효율적이나 상호 관련 서브 쿼리에 초점을 맞춘다.
```java
/*
    JPQL:
    select m from Member m
    where exists
        (select t from m.team t where t.name='팀A')
*/
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> mainQuery = cb.createQuery(Member.class);

//서브 쿼리에서 사용되는 메인 쿼리의 m
Root<Member> m = mainQuery.from(Member.class);

//서브 쿼리 생성
Subquery<Team> subQuery = mainQuery.subquery(Team.class);
Root<Member> subM = subQuery.correlate(m);  //메인 쿼리의 별칭을 가져옴
Join<Member, Team> t = subM.join("team");
subQuery.select(t)
        .where(cb.equal(t.get("name"), "팀A"));

//메인 쿼리 생성
mainQuery.select(m)
    .where(cb.exists(subQuery));

List<Member> resultList = em.createQuery(mainQuery).getResultList();
```
- 핵심) subQuery.correlate(m)
  - correlate(...) 메소드를 사용하면 메인 쿼리의 별칭을 서브 쿼리에서 사용할 수 있다.
  
### 10.3.8 IN 식
- IN 식은 Criteria 빌더에서 in(...) 메소드를 사용함
```java
/*
    JPQL:
    select m from Member m
    where m.username in ("회원1", "회원2)
 */
        
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> cq = cb.createQuery(Member.class);
Root<Member> m = cq.from(Member.class);

cq.select(m)
        .where(cb.in(m.get("username"))
            .value("회원1")
            .value("회원2"));
```

### 10.3.9 CASE 식
- CASE 식에는 selectCase() 메소드와 when(), otherwise() 메소드를 사용함
```java
/*
    JPQL:
    select m.username,
        case when m.age>=60 then 600
            when m.age<=15 then 500
            else 1000
        end
    from Member m        
 */

Root<Member> m = cq.from(Member.class);

cq.multiselect(
        m.get("username"),
        cb.selectCase()
            .when(cb.ge(m.<Integer>get("age"), 60), 600)
            .when(cb.le(m.<Integer>get("age"), 15), 500)
            .otherwise(1000)
);
```

### 10.3.10 파라미터 정의
- JPQL에서 :PARAM1 처럼 파라미터를 정의한 것 처럼 Criteria도 파라미터를 정의할 수 있음
```java
/*
    JPQL:
    select m from Member m
    where m.uesrname = :usernameParam
*/

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> cq = cb.createQuery(Member.class);

Root<Member> m = cq.from(Member.class);

//정의
cq.select(m)
        .where(cb.equal(m.get("username"), cb.parameter(String.class,
                "usernameParam")));

List<Member> resultList = em.createQuery(cq)
        .setParameter("usernameParam", "회원1")   //바인딩
        .getResultList();
```
1. cb.parameter(타입, 파라미터 이름) 메소드를 사용해서 파라미터를 정의했다.
2. setParameter("usernameParam", "회원1")을 사용해서 해당 파라미터에 사용할 값을 바인딩했다.

### 10.3.11 네이티브 함수 호출
- 네이티브 SQL 함수를 호출하려면 cb.function(..) 메소드를 사용하면 됨.
```java
Root<Member> m = cq.from(Member.class);
Expression<Long> function = cb.function("SUM", Long.class,
        m.get("age"));
cq.select(function);
```
- 여기서는 전체 회원의 나이 합을 구함 "SUM" 대신에 원하는 네이티브 SQL함수를 입력하면 됨

### 10.3.12 동적 쿼리
#### JPQL로 동적 쿼리를 만들면?
```java
//검색 조건
Integer age = 10;
String username = null;
String teamName = "팀A";

//JPQL 동적 쿼리 생성
StringBuilder jpql = new StringBuilder("select m from Member m join m.team t");
List<String> criteria = new ArrayList<String>();

if (age != null) criteria.add(" m.age = :age ");
if (username != null) criteria.add(" m.username = :username ");
if (teamName != null) criteria.add(" t.name = :teamName ");

if (criteria.size() > 0) jpql.append(" where ");

for (int i = 0; i < criteria.size(); i++) {
    if (i > 0) jpql.append(" and ");
    jpql.append(criteria.get(i));
}

TypedQuery<Member> query = em.createQuery(jpql.toString(), Member.class);
if (age != null) query.setParameter("age", age);
if (username != null) query.setParameter("username", username);
if (teamName != null) query.setParameter("teamName", teamName);

List<Member> resultList = query.getResultList();
```
- JPQL로 동적 쿼리를 구성하는 것은 아슬아슬한 줄타기
- 위와 같이 단순한 동적 쿼리 코드를 개발해도 문자 더하기로 인해 여러번 버그를 만날 것.
- 특히 문자 사이에 공백을 입력하지 않아서 age=:ageanduesrname=:username처럼
되는 것은 다들 한 번씩은 겪는 문제. where와 and의 위치를 구성하는 것도 신경 써야됨
  

#### Criteria로 동적 쿼리를 만들면?
```java
//검색 조건
Integer age = 10;
String username = null;
String teamName = "팀A";

//Criteria 동적 쿼리 생성
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> cq = cb.createQuery(Member.class);

Root<Member> m = cq.from(Member.class);
Join<Member, Team> t = m.join("team");

List<Predicate> criteria = new ArrayList<Predicate>();

if (age != null) criteria.add(cb.equal(m.<Integer>get("age"),
        cb.parameter(Integer.class, "age")));
if (username != null) criteria.add(cb.equal(m.get("username"),
        cb.parameter(String.class, "username")));
if (teamName != null) criteria.add(cb.equal(m.get("name"),
        cb.parameter(String.class, "teamName")));

cq.where(cb.and(criteria.toArray(new Predicate[0])));

TypedQuery<Member> query = em.createQuery(cq);
if (age != null) query.setParameter("age", age);
if (username != null) query.setParameter("username", username);
if (teamName != null) query.setParameter("teamName", teamName);

List<Member> resultList = query.getResultList();
```
- Criteria로 동적 쿼리를 구성하면 최소한 공백이나 where, and의 위치로 인해 에러가 발생하지는 않는다.
- 하지만 Criteria의 장황하고 복잡함으로 인해 코드가 읽기 힘들다는 단점은 여전히 남아 있다.

### 10.3.13 함수 정리
p.424 ~ p.426 참고

## 10. 4 QueryDSL
JPA Criteria는 너무 복잡하고 어렵다. 작성된 코드를 보면 복잡성으로 인해 어떤 jPQL이 생성될지 파악이 어려움.
QueryDSL는 Criteria보다 쉽고 간결하며 쿼리와 모양이 비슷하게 개발할 수 있다. Query DSL은 쿼리 즉
데이터를 조회하는 데 기능이 특화되어 있다.

### 10.4.1 QueryDSL 설정
[Spring Boot Data Jpa 프로젝트에 Querydsl 적용하기](https://jojoldu.tistory.com/372)

### 10.4.2 시작
- QueryDSL을 사용하려면 JPAQuery 객체를 생성해야 하는데 이때 엔티티 매니저를 생성자에 넘겨준다.
- 다음으로 사용할 쿼리 타입(Q)를 생성하는데 생성자에는 별칭을 주면 된다. 이 별칭을 JPQl에서 별칭으로 상용함.

```java
public void queryDSL() {
    EntityManager em = emf.createEntityManager();
    
    JPAQuery query = new JPAQuery(em);
    QMember qMember = new Qmember("m"); //생성되는 JPQL의 별칭이 m
    List<Member> members =
        query.from(qMember)
            .where(qMember.name.eq("회원1"))
            .orderBy(qMember.name.desc())
            .list(qMember);
}
```
- 실행된 JPQL
```jpaql
select m from Member m
where m.name = ?1
order by m.name desc
```

#### 기본 Q 생성
- 쿼리 타입 (Q)은 사용하기 편리하도록 기본 인스턴스를 보관하고 있음.
- but, 같은 엔티티를 조인하거나 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되므로 이때는 별칭을 직접 지정해서 사용한다.

```java
public class QMember extends EntityPachBase<Member> {
    
    public static final QMember member = new QMember("member1");
    ...
}
``` 
- 쿼리 타입은 다음과 같이 사용한다.
```java
QMember qMember = new QMember("m"); //직접 지정
QMember qMember = QMember.member;   //기본 인스턴스 사용
```
- 쿼리 타입의 기본 인스턴스를 사용하면 다음과 같이 import static을 활용해서 코드를 더 간결하게 작성할 수 있다.
```java
import static hasun.study.jpa.domain.QMember.member; //기본 인스턴스

public void basic() {
    
    EntityManager em = emf.createEntityManager();
    
    JPAQuery query = new JPAQuery(em);
    List<Member> members =
        query.from(member)
            .where(member.name.eq("회원1"))
            .orderBy(member.name.desc())
            .list(member);
}
```

### 10.4.3 검색 조건 쿼리
- QueryDSL의 기본 쿼리 기능을 다음 예제를 통해 알아본다.
```java
JPAQuery query = new JPAQuery(em);
QItem item = QItem.item;
List<Item> list = query.from(item)
    .where(item.name.eq("좋은상품")).and(item.price.gt(20000))
    .list(item);    //조회할 프로젝션 지정
```
- 위 예제를 실행하면 다음과 같이 JPQL이 생성되고 실행된다.
```java
select item
from Item item
where item.name = ?1 and item.price > ?2
```
- QueryDSL의 where 절에는 and나 or을 사용할 수 있음
- 여러 검색 조건을 사용해도 됨.
```java
.where(item.name.eq("좋은상품"), item.price.gt(20000))
```
- 쿼리 타입의 필드는 필요한 대부분의 메소드를 명시적으로 제공함.
- 몇가지 예를 통해 알아보자.
- 다음은 where()에서 사용되는 메소드
```java
item.price.between(10000, 20000);  //가격이 10000원 ~ 20000원 상품
item.name.contains("상품1");        //상품1이라는 이름을 포함한 상품,
                                   //SQL에서 like '%상품1%'을 검색
item.name.startsWith("고급");       //이름이 고급으로 시작하는 상품,
                                    //SQL에서 like '고급%' 검색
```
- 코드로 작성되어 있으므로 IDE가 제공하는 코드 자동 완성 기능의 도움을 받으면 필요한 메소드를 쉽게 찾을 수 있다.

### 10.4.4 결과 조회
- 쿼리 작성이 끝나고 결과 조회 메소드를 호출하면 실제 데이터베이스를 조회한다.
- 보통 uniqueResult()나 list()를 사용하고 파라미터로 프로젝션 대상을 넘겨준다.
- 결과 조회 API는 com.mysema,query.Projectable에 정의되어 있음
- 대표적인 결과 조회 메소드는 다음과 같다.

1. uniqueResult() : 조회 결과가 한 건일 때 사용. 조회 결과가 없으면 null을 반환하고 결과가 하나 이상이면 com.mysema.query.NonUniqueResultException 예외가 발생함.
2. singleReuslt() : uniqueResult()와 같지만 결과가 하나 이상이면 처음 데이터를 반환한다.
3. list() : 결과가 하나 이상일 때 사용함. 결과가 없으면 빈 컬렉션을 반환한다.

### 10.4.5 페이징과 정렬
```java
QItem item = QItem.item;

query.from(item)
    .where(item.price.gt(20000))
    .orderBy(item.price.desc(), item.stockQuantity.asc())
    .offset(10), limit(20)
    .list(item);
```
- 정렬은 orderBy를 사용하는데 쿼리 타입(Q)이 제공하는 asc(), desc()를 사용한다.
- 페이징은 offset과 limit을 적절히 조합해서 사용하면 됨.
- 페이징은 다음 예제과 같이 restrict() 메소드에 com.mysema.query.QueryModifiers를 파라미터로 사용해도 된다.

```java
QueryModifiers queryModifiers = new QueryModifiers(20L, 10L); //limit, offset
List<Item> list =
    query.from(item)
    .restrict(queryModifiers)
    .list(item);
```
- 실제 페이징 처리를 하려면 검색된 전체 데이터 수를 알아야 한다. 이때는 list() 대신 listResults()를 사용한다.
```java
SearchResults(Item) reuslt =
    query.from(item)
        .where(item.price.gt(10000))
        .offset(10).limit(20)
        .listResults(item);

long total = result.getTotal();     //검색된 전체 데이터 수
long limit = result.getLimit();
long offset = result.getOffset();
List<Item> results = result.getResults();   //조회된 데이터
```
- listResult()를 사용하면 전체 데이터 조회를 위한 count 쿼리를 한 번 더 실행한다.
- 그리고 SearchResults를 반환하는데 이 객체에서 전체 데이터 수를 조회할 수 있다.


### 10.4.6 그룹
- 그룹은 groupBy를 사용하고 그룹화된 결과를 제한하려면 having을 사용하면 된다.
```java
query.from(item)
    .groupBy(item.price)
    .having(item.price.gt(1000))
    .list(item);
```

### 10.4.7 조인
- 조인은 innerJoin(join), leftJoin, rightJoin, fullJoin을 사용할 수 있고
추가로 JPQL의 on과 성능 최적화를 위한 fetch 조인도 사용할 수 있다.
- 조인의 기본 문법의 첫 번째 파라미터에 조인 대상을 지정하고 두 번째 파라미터에 별칭으로 사용할 쿼리 타입을 지정하면 된다.
```java
join(조인 대상, 별칭으로 사용할 쿼리 타입)
```
- 다음 예제는 가장 기본적인 조인 방법이다.
```java
QOrder order = QOrder.order;
QMember member = QMember.member;
QOrderItem orderItem = QOrderItem.orderItem;

query.from(order)
    .join(order.member, member)
    .leftJoint(order.orderItems, orderItem)
    .list(order);
```
- 다음 예제에서는 조인에 on을 사용했다.
```java
query.from(order)
    .leftJoin(order.orderItem, orderItem)
    .on(orderItem.count.gt(2))
    .list(order);
```
- 다음 예제는 페치 조인을 사용하는 방법이다.
```java
query.from(order)
    .innerJoin(order.member, member).fetch()
    .leftJoin(order.orderItems, orderItem).fetch()
    .list(order);
```
- 다음 예제는 from 절에 여러 조인을 사용하는 세타 조인 방법이다.
```java
QOrder order = QOrder.order;
QMember member = QMember.member;

query.from(order, member)
    .where(order.member.eq(member))
    .list(order);
```

### 10.4.8 서브 쿼리
- 서브 쿼리는 다음 예제와 같이 com.mysema.query.jpa.JPASubQuery를 생성해서 사용한다.
- 서브 쿼리의 결과가 하나면 unique(), 여러 건이면 list()를 사용할 수 있다.
```java
QItem item = QItem.item;
QItem itemSub = new QItem("itemSub");

query.from(item)
    .where(item.price.eq(
            new JPASubQuery().from(itemSub).unique(itemSub.price.max())
        ))
    .list(item);
```
- 다음 예제는 여러 건의 서브 쿼리를 사용하는 방법이다.
```java
QItem item = QItem.item;
QItem itemSub = new QItem("itemSub";)

query.from(item)
    .where(item.in(
            new JPASubQuery().from(itemSub)
                .where(item.name.eq(itemSub.name))
                .list(itemSub)
        ))
    .list(item);
```

### 10.4.9 프로젝션과 결과 반환
- select 절에 조회 대상을 지정하는 것을 프로젝션이라 한다.

### 프로젝션 대상이 하나
- 프로젝션 대상이 하나면 다음 예제와 같이 해당 타입으로 반환한다.
```java
QItem item = QItem.item;
List<String> result = query.from(item).list(item.name);

for (String name : reuslt) {
    System.out.println("name = "+name);    
}
```

### 여러 컬럼 반환과 튜플
- 프로젝션 대상으로 여러 필드를 선택하면 QueryDSL은 기본으로 com.mysema.query.Tuple이라는 Map과 비슷한 내부 타입을 사용함.
- 조회 결과는 tuple.get() 메소드에 조회한 쿼리 타입을 지정하면 됨.
```java
QItem item = QItem.item;

List<Tuple> result = query.from(item).list(item.name, item.price);
//List<Tuple> result = query.from(item).list(new QTuple(item.name, item.price)); 와 같다.

for (Tuple tuple : result) {
    System.out.println("name = "+tuple.get(item.name));
    System.out.println("price = "+tuple.get(item.price));
}
```

### 빈 생성
- 쿼리 결과를 엔티티가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용함.
- QueryDSL은 객체를 생성하는 다양한 방법을 제공한다.
  - 프로퍼티 접근
  - 필드 직접 접근
  - 생성자 사용
  
- 원하는 방법을 지정하기 위해 com.mysema.query.types.Projections를 사용하면 됨.

```java
public class ItemDTO {
    
    private String username;
    private int price;
    
    public ItemDTO() {}
  
    public ItemDTO(String username, int price) {
        this.username = username;
        this.price = price;
    }
    
    //Getter, Setter
    public String getUsername() {...}
    public void setUsername(String username) {...}
    public int getPrice() {...}
    public void setPrice(int price) {...}
}
```
#### 프로퍼티 접근(setter)
```java
QItem item = QItem.item;
List<ItemDTO> result = query.from(item).list(
        Projections.bean(ItemDTO.class, item.name.as("usrename"), item.price));
```
- Projections.bean() 메소드는 수정자를 사용해서 값을 채운다.
- 예제를 보면 쿼리 결과는 name인데 ItemDTO username 프로퍼티를 가지고 있다.
- 이처럼 쿼리 결과와 매핑할 프로퍼티 이름이 다르면 as를 사용해서 별칭을 주면 된다.

#### 필드 직접 접근
```java
QItem item = QItem.item;
List<ItemDTO> result = query.from(item).list(
        Projections.fields(ItemDTO.class, item.name.as("username"),
            item.price));
```
- Proejctions.fields() 메소드를 사용하면 필드에 직접 접근해서 값을 채워준다.
- 필드를 private로 설정해도 동작한다.

#### 생성자 사용
```java
QItem item = QItem.item;
List<ItemDTo> result = query.from(item).list(
        Projections.constructor(ItemDTO.class, item.name, item.price));
```
- Projections.constructor() 메소드는 생성자를 사용함.
- 물론 지정한 프로젝션과 파라미터 순서가 같은 생성자가 필요하다.


### DISTINCT
- distinct는 다음과 같이 사용한다.
```java
query.distinct().from(item)...
```

### 10.4.10 수정, 삭제, 배치 쿼리
- QueryDSL도 수정, 삭제 같은 배치 쿼리를 지원한다.
- JPQL 배치 쿼리와 같이 영속성 컨텍스트를 무시하고 데이터베이스를 직접 쿼리한다는 점에 유의하자.

```java
QItem item = QItem.item;
JPAUpdateClause updateClause = new JPAUpdateClause(em, item);
long count = updateClause.where(item.name.eq("시골개발자의 JPA 책"))
    .set(item.price, item.price.add(100))
    .excute();
```
- 위 예제와 같이 수정 배치 쿼리는 com.mysema.query.jpa.impl.JPAUpdateClause를 사용함.
- 위 예제는 상품의 가격을 100원 증가시키는 예제이다.

- 삭제 배치 쿼리
```java
QItem item = QItem.item;
JPADeleteClause deleteClause = new JPADeleteClause(em, item);
long count = deleteClause.where(item.name.eq("시골개발자의 JPA 책"))
    .excute();
```
- 삭제 배치 쿼리는 com.mysema.query.jpa.impl.JPADeleteClause를 사용함
- 위 예제는 이름이 같은 상품을 삭제한다.

### 10.4.11 동적 쿼리
= com.mysema.query.BooleanBuilder를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있음
```java
SearchParam param = new SearchParam();
param.setName("시골개발자");
param.setPrice(10000);

QItem item = QItem.item;

BooleanBuilder builder = new BooleanBuilder();
if (StringUtils.hasText(param.getName())) {
    builder.and(item.name.contains(param.getName()));    
}
if (param.getPrice() != null) {
    builder.and(item.price.gt(param.getPrice()));    
}
List<Item> result = query.from(item)
    .where(builder)
    .list(item);
```
- 위 예제는 상품 이름과 가격 유무에 따라 동적으로 쿼리를 생성함.

### 10.4.12 메소드 위임
- 메소드 위임 기능을 사용하면 쿼리 타입에 검색 조건을 직접 정의할 수 있다.
```java
public class ItemExpression {
    
    @QueryDelegate(Item.class)
    public static BooleanEcpression isExpensive(QItem item, Integer price) {
        return item.price.gt(price);
    }
}
```
- 메소드 위임 기능을 사용하려면 위 예제와 같이 정적 (static) 메소드를 만들고
@com.mtsema.query.annotations.QueryDelegate 어노테이션에 속성으로 이 기능을 적용할 엔티티를 지정한다.
- 정적 메소드의 첫 번째 파라미터에는 대상 엔티티의 쿼리 타입(Q)를 지정하고 나머지는 필요한 파라미터를 정의한다.

```java
public class QItem extends EntityPathBase<Item> {
    ... 
    public com.mysema.query.types.expr.BooleanExpression
        isExpensive(Integer price) {
        return ItemExpression.isExpensive(this, price);
    }
}
```
- 위 예제의 생성된 쿼리 타입을 보면 기능이 추가된 것을 확인할 수 있다.
- 이제 메소드 위임 기능을 사용해본다.
```java
query.from(item).where(item.isExpensive(30000)).list(item);
```
- 필요하다면 String, Date 같은 자바 기본 내장 타입에도 메소드 위임 기능을 사용할 수 있다.

```java
@QueryDelegate(String.class)
public static BooleanExpression isHelloStart(StringPath stringPath) {
    return stringPath.startWith("Hello");    
}
```

#### 10.4.13 QueryDSL 정리
- JPA를 사용하면서 생기는 고민 두가지
  - 문자가 아닌 코드로 안전하게 쿼리를 작성하고 싶다.
  - 복잡한 동적 쿼리를 어떻게 해결해야 하는가?
  
- JPA Criteria가 해결해 주기는 했지만, Criteria는 막상 사용해보면 너무 복잡해서
오히려 JPQL을 직접 사용하고 싶어짐.
- 반면, QueryDSL은 두 가지를 모두 만족하면서, 쉽고 단순하다.

