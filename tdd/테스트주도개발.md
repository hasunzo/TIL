# 테스트 주도 개발 Test Driven Development By Example (By Kent Beck)
# 들어가는 글
    " 어떤 코드건 작성하기 전에 실패하는 자동화된 테스트를 작성하라. "
    " 중복을 제거하라 "
# 01 화폐 예제
### 테스트 주도 개발(TDD)의 리듬
* 재빨리 테스트를 하나 추가한다.
* 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
* 코드를 조금 바꾼다.
* 모든 테스트를 실행하고 전부 성공하는지 확인한다
* 리팩토링을 통해 중복을 제거한다.
## 1-1. 다중 통화를 지원하는 Money 객체
* 워드가 와이캐시에서 만들었던 다중 통화를 지원하는 Money 객체

|종목|주|가격|합계|
|:---:|:---:|:---:|:---:|
|IBM|1000|25|25000|
|GE|400|100|40000|
|-|-|합계|65000|
* 다중 통화를 지원하는 보고서를 만들려면 통화 단위를 추가해야 한다. 
  
|종목|주|가격|합계|
|:---:|:---:|:---:|:---:|
|IBM|1000|25USD|25000USD|
|Novartis|400|150CHF|60000CHF|
|-|-|합계|65000USD|
- 환율도 명시해야 한다.

|기준|변환|환율|
|:---:|:---:|:---:|
|CHF|USD|1.5|
    $5 + 10CHF = $10(환율이 2:1일 경우)
    $5 x 2 = $10

### ✔ 할일 목록 만들기
> 어떤 테스트를 통과해야 코드가 완성됐다는 걸 확신할 수 있을까?

* (1) 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
* (2) 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.
###### 💡 할일 목록에서 좀 더 수월해보이는 걸 먼저 수행하는 것이 좋다.

### ✔ 할일 목록에 있는 한 항목에 대한 작업 시작하기 (2번)
```java
public void testMultiplication() {
    Dollar five = new Dollar(5);
    five.times(2);
    assertEquals(10, five.amount);
}
```
###### 💡 현재 목표는 최대한 빨리 초록 막대를 보는 것이기 때문에 다른 문제들은 일단 무시하자
    $5 + 10CHF = $10(환율이 2:1일 경우)
    $5 x 2 = $10
    amount를 private으로 만들기
    Dollar 부작용(side effect)?
    Money 반올림?
- 위에서 작성한 테스트 코드는 컴파일조차 되지 않는다.
- 실행은 안 되더라도 컴파일만이라도 되게 하기위해선 어떻게 해야하는가?

### ✔ 컴파일만이라도 되도록 컴파일 에러를 해결해보자
- Dollar 클래스가 없음
- 생성자가 없음
- times(int) 메서드가 없음
- amount 필드가 없음
```java
class Dollar {
    Dollar(int amount) {}
    void times(int multiplier) {}
    int amount;
}
```
- Dollar 클래스 정의
- 생성자 만들기
- times()의 스텁 구현
- amount 필드 추가
> 실패! expected:<10> but was:<0>

👉 여기서 할 수 있는 최소 작업은 무엇일까? <br>
```java
int amount = 10;
```
> 성공! but 단순한 구현을 통과시켜줄 만한 입력값은 정말로 찾기 힘들다. 계속 진행하기 전에 일반화를해야 한다.

### 📌 테스트 주기
1. 작은 테스트를 하나 추가한다.
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인한다.
3. 조금 수정한다.
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인한다.
5. 중복을 제거하기 위해 리팩토링을 한다.
> 의존성과 중복
> >만약 특정 데이터베이스 벤더가 제공하는 세세한 기능들을 여기저기 사용하는 상황에서
> 데이터베이스를 다른 벤더로 변경하고자 하면
> 코드가 해당 벤더에 대해 의존성을 갖는다는 사실을 알게 될 것이다. 
> 이는 코드의 변경없이는 벤더를 바꿀 수 없음을 의미한다. <br>
> 의존성이 문제 그 자체라면 중복은 문제의 징후다. 중복의 가장 흔한 예는 동일한 문장이 코드의 여러 장소에 나타나는 로직의 중복이다.
> 중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다. <br>
> 👉 프로그램에서는 중복만 제거해 주면 의존성도 제거된다. 다음 테스트로 진행하기 전, 중복을 제거함으로써 오직 한 가지(one and only one)의
> 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화하는 것이다.

### ✔ 중복을 제거해보자
* 중복이 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다. 코드를 살짝 바꿔보자.
```java
int amount = 5 * 2;
```
* 이렇게 보면 테스트에 있는 데이터 (생성자에서 넘겨준 값 : 5, times 함수에 넘겨준 값 : 2) 와 코드에 있는 데이터 ( 5 * 2 ) 사이에 중복이 있음을 찾을 수 있다.
* 한번에 제거할 순 없다. 작은 단계부터 밟아보자
```java
int amount;

void times(int multiplier) {
    amount = 5 * 2;
}
```
* 여기서 또 쪼갤 수 있을까?
* 5를 어디서 얻을 수 있을까? 생성자에서 얻을 수 있다!
```java
Dollar(int amount) {
    this.amount = amount;
}
```
* 여기서 얻은 5를 times()에서 사용해보자
```java
void times(int multiplier) {
    amount = amount * 2;
}
```
* 파라미터로 넘어 온 인자 'multiplier'의 값이 2 이므로 대체해주자
```java
void times(int multiplier) {
    amount = amount * multiplier;
}
```
* 자바 문법을 완벽하게 알고 있다는 것을 보여주기 위해 *= 연산자도 써보자
```java
void times(int multiplier) {
    amount *= multiplier;
}
```
### ✔ 완성 코드
```java
class Dollar {
    Dollar(int amount) {
        this.amount = amount;
    }
    int amount;
    void times(int multiplier) {
        amount *= multiplier;
    }
}
```
    $5 + 10CHF = $10(환율이 2:1일 경우)
    ✅ $5 x 2 = $10 (완료)
    amount를 private으로 만들기
    Dollar 부작용(side effect)?
    Money 반올림?

### ✔ 지금까지 한 작업 검토
- 우리가 알고 있는 작업해야 할 테스트 목록을 만들었다.
- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현했다.
- Junit에 대한 상세한 사항들은 잠시 무시하기로 했다.
- 스텁 구현을 통해 테스트를 컴파일했다.
- 끔찍한 죄악을 범하여 테스트를 통과시켰다.
- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화했다.
- 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.