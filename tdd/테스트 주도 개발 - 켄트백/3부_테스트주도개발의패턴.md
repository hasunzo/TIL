# 3부 테스트 주도 개발의 패턴
## 25장 테스트 주도 개발 패턴
> 기본적인 전략에 관한 질문
- 테스트한다는 것은 무엇을 뜻하는가?
- 테스트를 언제 해야 하는가?
- 테스트할 로직을 어떻게 고를 것인가?
- 테스트할 데이터를 어떻게 고를 것인가?

### 테스트(명사)
> 작성한 소프트웨어를 어떻게 테스트할 것인가?
- 자동화된 테스트를 만들어라!
- 테스트하다(test) - '평가하다'
- 그 어떤 소프트웨어 엔지니어도, 아주 확신에 찬 사람과 정말 얼렁뚱땅 넘어가는 사람을 제외한다면,
아무리 작은 변화라도 테스트하지 않고 릴리즈하지는 않는다.
  
> 양성 피드백 고리
- 스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다.
- 테스트를 뜸하게 하면 당신이 만드는 에러는 점점 많아질 것이다.
- 에러가 많아지면 더 많은 스트레스를 받게된다.
- 씻어내고 다시 반복하라 (rinse and repeat)

> 어떻게 하면 이 고리에서 빠져나올 수 있을까?
- 새로운 요소를 도입하거나, 기존 요소와 바꿔치기 하거나, 화살표를 바꾸면 된다.
- 이 경우엔 '테스트'를 '자동화된 테스트'로 치환하면 된다.
- 자동화된 테스트가 있다면, 스트레스를 받기 시작할 때 테스트를 실행할 것이다.
- 테스트는 프로그래머를 위한 묘석인데, 두려움을 지루함으로 바꿔주는 효험이 있다.
- 테스트를 실행하면 즉시 좋은 느낌을 받게 되고 (초록 막대를 보았을 시) 그러면 작업 중에 에러를 낼 일도 줄게 되며, 스트레스도 적어진다.

### 격리된 테스트
> 테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가?
- 아무 영향이 없어야 한다.

> 경험에서 얻은 두 가지 교훈
- 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자는 것
- 어마어마한 양의 종이더미가 반드시 어마어마한 양의 문제를 의미하는 것은 아니라는 점
- 테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다
- 각각의 테스트는 다른 테스트와 완전히 독립적이어야 한다는 것
- 즉, 문제가 하나면 테스트도 하나만 실패해야 하고, 문제가 둘이면 테스트도 두 개만 실패해야 한다.

> 격리된 테스트가 암묵적으로 내포하는 특징 중 하나는 테스트가 실행 순서에 독립적이게 된다는 점이다.
- 테스트의 일부만 실행해보고 싶으면, 선행 테스트가 실행되지 않아서 내가 고른 테스트들이 실패하지 않을까 걱정할 필요 없이 그렇게 할 수 있어야 한다.

> 격리된 테스트가 내포하는 것
- 주어진 문제를 작은 단위로 분리하기 위해 노력해서 각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다는 것
- 테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.

### 테스트 목록
> 뭘 테스트해야 하나?
- 시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것.
- 프로그래밍 스트레스를 줄이기 위한 우리 접근법의 첫 단계는 발 디딜 곳이 확실해지기 전엔 결코 발을 떼어 전진하지 말자는 것이다.

> 목표에서 벗어나지 않고 집중할 수 있는 한 가지 전략은 모든 걸 머릿속에 넣어두는 것
- 경험이 축적될수록 할일 목록이 많아진다.
- 할일 목록이 많아질수록 내가 하던 일에 대한 집중력이 떨어지고 성취도는 낮아진다.
- 성취도가 낮아지면 할일 목록은 더 많아진다.
- 그냥 머릿속에 있는 목록에서 임의의 항목을 무시하고 변덕스럽게 프로그래밍해 봤지만, 이 고리를 깨지는 못했다.

> 향후 몇 시간 내로 해치워야 하는 모든 할일 목록을 컴퓨터 옆에 있는 종이 조각에 적어놓는 습관을 가지자
- 주 혹은 월 단위 목록도 만들어서 벽에 붙여둔다.
- 이걸 다 적기만 하면 앞으로는 할일을 놓치지 않게 될 것이다.
- 새로운 항목이 나타나면 나는 빠르고 의식적으로 이 항목이 '지금' 할일에 속하는지 '나중에' 할일에 속하는지, 또는 할 필요가 없는 일인지를 결정한다.

> 이를 테스트 주도 개발에 적용해보면, 구현해야 할 것들에 대한 테스트를 목록에 적게 된다.
- 우선 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.
- 그 다음, 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전(아무 일도 하지 않는 버전)을 리스트에 적는다.
- 마지막으로 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 적는다.

> 테스트를 한번에 다 만들어 놓는 방법이 먹히지 않았던 이유
- 만들어진 모든 테스트는 리팩토링에 대해 약간의 관성을 갖는다.
    - 자동화된 리팩토링 도구(예를 들어 변수의 선언부와 모든 참조를 찾아서 한번에 이름 바꾸기를 수행해 주는 메뉴 항목 같은 것)가 있다면 별 문제가 되지 않는다.
    - 그렇지 않다면 열 개의 테스트를 만든 후에 매개 변수의 순서를 반대로 하는 게 좋을 거라는 사실을 발견하더라도 아마 이 순서를 바꾸지 않으려 할 것이다.
- 열 개의 테스트가 실패했다면 초록 막대를 보는 것은 한참 멀었다.
    - 빨리 초록막대를 볼 방법은 열 개의 테스트를 몽땅 지워버리는 것 뿐이다.
    - 만약 모든 테스트가 통과하도록 하려면 오랫동안 빨간 막대 상태에 머물러야 한다.
    
> 테스트를 통과하게 만드는 과정에서 여러분이 작성한 코드들은 새로운 테스트가 필요함을 암시적으로 알려줄 것이다. 이 새 테스트를 리팩토링과 마찬가지로 할일 목록에 적어 놓아라.

- 제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈 하는 것보다 더 중요하다.

### 테스트 우선
> 테스트를 언제 작성하는 것이 좋을까?
- 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.

> 코드를 작성한 후에는 테스트를 만들지 않을 것이다.
- 프로그래머로서의 목표는 기능이 실행되도록 만드는 것이다.
- 하지만 한편으로는 프로그램의 설계에 대해 생각해볼 시간도 필요하고 작업 범위를 조절할 방법도 필요할 것이다.

> 테스트를 먼저 해야 한다는 규칙을 도입하자
- 영향도를 뒤집을 수 있고 효과적인 주기를 만들어내게 된다.
- 테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다.

### 단언 우선
> 테스트를 작성할 때 단언(assert)은 언제쯤 쓸까?
- 단언을 제일 먼저 쓰고 시작하라. 자기유사성(self-similarity)란 참 멋지지 않은가?

- 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다.
  - 통상 자그마한 인덱스 카드 한 장에 하나의 스토리를 기록한다.
- 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.
- 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

> 단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다.
- 테스트만 작성할 때도 사실 여러분은 몇 가지 문제들을 한번에 해결하는 것이다.
  - 테스트하고자 하는 기능이 어디에 속하는 걸까? 기존의 메서드를 수정해야 하나, 기존의 클래스에 새로운 메서드를 추가해야 하나, 아니면 이름이 같은 메서드를 새 장소에? 또는 새 클래스에?
  - 메서드 이름을 뭐라고 해야 하나?
  - 올바른 결과를 어떤 식으로 검사할 것인가?
  - 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?
- 이 많은 문제를 한번에 잘 해결하기엔 문제가 좀 있다. 이 중 "올바른 결과는 무엇인가?", "어떤 식으로 검사할 것인가?"는 나머지 문제에서 쉽게 분리할 수 있다.

> 소켓 통신 예시
- 소켓을 통해 다른 시스템과 통신하려 한다고 가정하자.
- 통신을 마친 후 소켓은 닫혀 있고, 소켓에서 문자열 'abc'를 읽어와야 한다고 치자
```java
testCompleteTransaction() {
    ...
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- reply는 어디서 얻어오나? 물론 socket이다.
```java
testCompleteTransaction() {
    ...
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 그럼 socket은 어디에서 나오나? 서버에 접속할 때 생성된다.
```java
testCompleteTransaction() {
    ...
    Socket reader= Socket("localhost", defaultPort());
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 물론 이 작업을 하기 전에 서버를 먼저 열어야 한다.
```java
testCompleteTransaction() {
    Server writer= Server(defaultPort(), "abc")
    Socket reader= Socket("localhost", defaultPort());
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 아직 실제 용도에 맞게 이름을 수정하는 일이 남아 있긴 하지만 지금까지 아주 작은 단계로 빠른 피드백을 받으며 테스트의 아웃라인을 만들었다.


### 테스트 데이터
> 테스트할 때 어떤 데이터를 사용해야 하는가?
- 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용해라.
- 테스트 작성에도 청중이 존재한다.
- 단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라.
- 데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야 한다.
- 1과 2 사이에 어떠한 개념적 차이점도 없다면 1을 사용하라.
- 만약 시스템이 여러 입력을 다루어야 한다면 테스트 역시 여러 입력을 반영해야 한다. 하지만 세 항목만으로 동일한 설계와 구현을 이끌어낼 수 있다면 굳이 항목을 열 개나 나열할 필요는 없다.

> 테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다.
- 만약 plus() 메서드를 구현하려고 한다면 고전적 예제인 2+2 혹은 1+1을 쓰고 싶을 것이다.
- 만약 구현에서 인자의 순서가 뒤집힌다면 어떻게 될까?
  - plus()에서야 순서가 뒤집혀도 상관이 없겠지만...
- 우리가 첫 번째 인자로 2를 썼다면 두 번째 인자는 3을 써야 한다.

> 테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실세 데이터를 사용하는 것이다.
> 실제 데이터는 다음가 같은 경우에 유용하다.
- 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
- 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우(병렬 테스팅).
- 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우.
  - 특히 부동소수점 값의 정확성이 문제가 될 수 있다.
  
### 명백한 데이터
> 데이터의 의도를 어떻게 표현할 것인가?
- 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.

> 통화 환전 예시
- 한 통화를 다른 통화로 환전하려고 하는데, 이 거래에는 수수료 1.5%가 붙는다.
- USD에서 GBP로 교환하는 환율이 2:1이라면 $100를 환전하려면 50GBP - 1.5% = 49.25GBP여야 한다.
```java
Bank bank= new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result= bank.convert(new Note(100, "USED"), "GBP");
assertEquals(new Note(49.25, "GBP"), result);
```
- 또는 계산을 더 명확히 표현할 수도 있다.
```java
Bank bank= new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result= bank.convert(new Note(100, "USED"), "GBP");
assertEquals(new Note(100 / 2 * (1 - 0.015), "GBP"), result);
```
- 이 테스트에서는 입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 읽어낼 수가 있다.

> 명백한 데이터가 주는 또 다른 이점
- 프로그래밍이 더 쉬워진다.
- 단언 부분에 일단 수식을 써놓으면 다음으로 무엇을 해야 할지 쉽게 알게 된다.
- 이런 경우 어떻게든 나눗셈과 곱셈을 수행할 프로그램을 만들어야 한다는 걸 알게 되는 것이다.
- 이 오퍼레이션이 어디에 속할지를 점진적으로 알아내기 위해 가짜 구현을 해볼 수도 있다.

## 26장 빨간 막대 패턴
- 이 패턴들은 테스트를 언제 어디에 작성할 것인지, 테스트 작성을 언제 멈출지에 대한 것이다.

### 한 단계 테스트
> 목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가?
- 여러분에게 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것.
- 각 테스트는 여러분을 최종 목표로 한 단계 진전시켜 줄 수 있어야 한다. 다음 테스트 목록 중 무엇을 고르는게 좋을까?
  - 더하기
  - 빼기
  - 곱하기
  - 나누기
  - 비슷한 것 더하기
  - 동치성(equals)
  - 널과의 동치성(equals null)
  - 널 환전
  - 한 개의 통화를 환전하기
  - 두 개의 통화를 환전하기
  - 환시세
- 정답은 없다. 내가 이런 걸 한번도 만들어 보지 않았다고 치면, 내게 한 단계의 크기는 경험이 풍부한 여러분의 한 단계에 비해 1/10 정도일 것이다.
- 이 목록에서 한 단계 전진을 나타낼 만한 것을 못 찾았다면 직접 하나 추가해 보기 바란다

> 테스트 목록을 볼 땐 보통 이런 식이다.
- "이건 뻔하지, 이것도 뻔하고, 이건 잘 모르겠군, 이건 뻔하고, 이건... 내가 무슨 생각으로 적은 거지? 아, 이건 할 수 있겠다."
- 이 마지막 테스트가 바로 내가 다음으로 구현할 테스트인 것이다.
- 뻔하진 않지만 구현할 수 있다는 확신이 있다.

- 전체 계산 중 간단한 하나의 사례를 나타내는 테스트에서 시작했다면
  - 이 테스트를 통해 자라는 프로그램은 하향식(top-down)으로 작성된 것
- 반면 전체의 작은 한 조각을 나타내는 테스트에서 시작하여 조금씩 붙여나가는 식이었다면
  - 이 프로그램은 상향식(bottom-up)으로 작성된 것으로 보일 수도 있다.
  
> 사실은 상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해 줄 수 없다.
- 첫째로 이와 같은 수직적 메타포는 프로그램이 시간에 따라 어떻게 변해 가는지에 대한 단순화된 시각일 뿐이다.

> 이보다 성장(growth)이란 단어를 보자.
- '성장'은 일종의 자기유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환견이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.
- 둘쨰로, 만약 메타포가 어떤 방향성을 가질 필요가 있다면 (상향 혹은 하향보다는)
  - '아는 것에서 모르는 것으로(known-to-unknown'라는 방향이 유용할 것이다.
  - 이는 우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.
- 우리는 아는 것에서 모르는 것으로 성장하는 프로그램을 갖게 된다.

### 시작 테스트
> 어떤 테스트부터 시작하는 게 좋을까?
- 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트할 것.
- 새 오퍼레이션에 대한 첫 질문은 다음과 같을 것이다.
  - "이 오퍼레이션을 어디에 넣어야 하지?"
- 이 질문에 답하기 전까지는 테스트에 뭘 적어야 할 지 알 수 없을 것이다.
- 한 번에 한 문제만 해결하자는 의미에서 다른 질문은 다 빼고 딱 이 질문만 생각할 방법은 무엇인가?

> 첫 걸음으로 현실적인 테스트를 하나 작성한다면 상당히 많은 문제를 한번에 해결해야 하는 상황이 될 것이다.
- 이 오퍼레이션을 어디에 두어야 하나?
- 적절한 입력 값은 무엇인가?
- 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

> 현실적인 테스트 하나로 시작하면 너무 오랫동안 피드백이 없을 것이다.
- 빨갈/초록/리팩토링, 빨강/초록/리팩토링. 여러분은 이 고리가 몇 분 내에로 반복되길 원할 것이다.

> 정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.
- 예를 들어 XP 뉴스그룹에 누군가가 다각형 축소기(polygon reducer)를 테스트 우선으로 어떻게 작성할지 질문했다.
- 입력을 다각형 그물이고, 출력은 정확하게 똑같은 표면이면서 가능한 한 최소 개수의 다각형으로 구성된 다각형 그물이 된다.
- "테스트를 작동하도록 하는 데 박사 학위 논문을 읽어야 하는 경우, 이 문제를 어떻게 테스트 주도로 접근할 수 있을까요?"

> 시작 테스트 패턴이 이 문제에 대한 답을 준다.
- 출력이 입력과 같은 경우가 있다. 어떤 형상(configuration)의 다각형들은 이미 정규화되어 있고 더 축소할 수 없다.
- 입력은 가능한 한 적어야 한다. 이를테면 다각형 하나 또는 아예 비어있는 다각형 목록일 수 있다.
- 다음 시작 테스트를 작성했다.
```java
Reducer r= new Reducer(new Polygon());
assertEquals(0, reducer.result().npoints);
```
- 짠! 첫 번째 테스트가 돌아간다. 이제 목록에 있는 나머지 테스트를 처리할 차례다.

> 한 단계 테스트는 시작 테스트에도 적용된다. 
- 당신에게 뭔가를 가르쳐줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라.
- 만약 당신이 어떤 애플리케이션을 n번째 구현하고 있다면, 오퍼레이션을 한두 개 필요로 하는 테스트를 하나 골라라.
- 당신은 그걸 작동하게 할 수 있을 거라 자신할 것이다.
- 만약 뭔가 어렵고 복잡한 것을 처음 구현해보고 있다면 당신은 즉각 조그만 용기의 알약을 하나 먹어야 한다.
- 많은 경우 나의 시작 테스트는 그 이후의 테스트에 비해 좀더 높은 차원의 테스트로, 애플리케이션 테스트와 비슷하다.
- 내가 자주 테스트 주도로 개발하는 예 중 하나는 간단한 소켓 기반 서버이다.
- 첫 번째 테스트
```java
StartServer
Socket= new Socket
Message= "hello"
Socket.write(message)
AssertEquals(message, socket.read)
```
- 이제 나머지 테스트는 서버만으로 이루어질 수 있다. 
- "우리가 이런 문자열을 받았다고 치고...."

### 설명 테스트
> 자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까?
- 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라.
- 팀에서 혼자 TDD를 한다면 꽤나 어려움을 느낄 수도 있다.
- 하지만 머지않아, 테스트된 코드의 통합 문제와 결함 보고가 줄어드는 것을 팀에서 알아챌 것이고, 설계는 더 단순해지고 설명하기에 용이해질 것이다.
- 심지어 사람들이 테스트와 테스트 우선에 정말 열광적이게 되는 일이 발생할 수 있다.

### 학습 테스트
> 외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 떄도 있을까?
- 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다.

- 자바의 모바일 정보 기기 프로파일 라이브러리를 기반으로 뭔가를 만들어야 한다고 치자.
- Record-Store에 어떤 데이터를 저장하고 이를 받아오고자 한다.
- 그냥 코딩하고선 그게 잘 돌아가길 바라는 게 좋을까? 그것도 한 방법이긴 하다.

> 한 가지 대안은 우리가 이제 막 새 클래스의 새 메서드를 하나 사용한다는 것을 알아채는 것이다.
- 그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다.

```java
public void setUp() {
    store= RecordStore.openRecordStore("testing", true);    
}

public void tearDown() {
    RecordStore.deleteRecordStore("testing");
}

public void testStore() {
    int id= store.addRecord(new byte[] {5, 6}, 0, 2);
    assertEquals(2, store.getRecordSize(id));
    byte[] buffer= new byte[2];
    assertEquals(2, store.getRecord(id, buffer, 0));
    assertEquals(5, buffer[0]);
    assertEquals(6, buffer[1]);
}
```
- 만약 우리가 API를 제대로 이해했다면 이 테스트는 한번에 통과할 것이다.
- 패키지의 새 버전이 도착하면 우선 테스트를 실행한다. (그리고 필요하다면 수정한다.)
- 만약 테스트가 통과되지 않느다면 애플리케이션 역시 실행되지 않을 것이 뻔하기 때문에 애플리케이션을 실행해볼 필요도 없다.
- 일단 테스트가 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다.

### 또 다른 테스트
> 어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있을까?
- 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것.
- 대화를 엄격하게 한 주제로 묶는 것은 훌륭한 아이디어를 억압하는 최고의 방법이다.
- 이리 저리 건너뛰어 다니다가 "도대체 어쩌다 이런 얘길 하고 있는거지? 무슨 상관이람, 이거 참 좋은 아이디어인데!" 하고 생각하는 것이다.

> 새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다.
- 그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다.

### 회귀 테스트
> 시스템 장애가 보고될 때 여러분은 무슨 일을 제일 먼저 하는가?
- 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라.

> 회귀 테스트란,(regresstion test)
- 처음 코딩할 때 작성했어야 하는 테스트다.
- 회귀 테스트를 작성할땐 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해보라.
- 애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다.
- 좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이된다.
- 기괴할 정도로 큰 음수에 대한 결함보고서가 있을 수 있다.
- 여기에서는 테스트 목록을 작성할 때 정수 롤오버를 테스트할 필요가 있다는 것을 배울 수 있다.

> 시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야 한다.
- 이러한 종류의 장애가 있다는 것은, 시스템이 여러분에게 다음과 같은 말을 한다는 뜻이다.
- "아직 내 설계를 마무리 못했구먼."


### 휴식
> 지치고 고난에 빠졌을 땐 뭘 해야 하나? 
- 그럴 땐 좀 쉬는게 좋다.

> 데이브 웅가(Dave Ungar)의 샤워 방법론
- 키보드로 뭘 쳐야 할지 알면, 그걸 치면 된다.
- 뭘 해야 할지 모르겠으면 샤워하러 가서 뭘 해야 할지 생각날 때까지 계속 샤워를 한다.
- TDD는 웅가의 샤워 방법론을 정제한 것이다.
- 키보드로 뭘 쳐야 할지 알면, 명백한 구현을 한다.
- 잘 모르겠다면 가짜 구현을 한다.
- 올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다.


### 다시 하기
> 길을 잃은 느낌이 들 땐 어떻게 해야 할까?
- 코드를 다 지워버리고 처음부터 다시 해보자.


