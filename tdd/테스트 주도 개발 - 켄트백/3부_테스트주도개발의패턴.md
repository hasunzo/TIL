# 3부 테스트 주도 개발의 패턴
## 25장 테스트 주도 개발 패턴
> 기본적인 전략에 관한 질문
- 테스트한다는 것은 무엇을 뜻하는가?
- 테스트를 언제 해야 하는가?
- 테스트할 로직을 어떻게 고를 것인가?
- 테스트할 데이터를 어떻게 고를 것인가?

### 테스트(명사)
> 작성한 소프트웨어를 어떻게 테스트할 것인가?
- 자동화된 테스트를 만들어라!
- 테스트하다(test) - '평가하다'
- 그 어떤 소프트웨어 엔지니어도, 아주 확신에 찬 사람과 정말 얼렁뚱땅 넘어가는 사람을 제외한다면,
아무리 작은 변화라도 테스트하지 않고 릴리즈하지는 않는다.
  
> 양성 피드백 고리
- 스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다.
- 테스트를 뜸하게 하면 당신이 만드는 에러는 점점 많아질 것이다.
- 에러가 많아지면 더 많은 스트레스를 받게된다.
- 씻어내고 다시 반복하라 (rinse and repeat)

> 어떻게 하면 이 고리에서 빠져나올 수 있을까?
- 새로운 요소를 도입하거나, 기존 요소와 바꿔치기 하거나, 화살표를 바꾸면 된다.
- 이 경우엔 '테스트'를 '자동화된 테스트'로 치환하면 된다.
- 자동화된 테스트가 있다면, 스트레스를 받기 시작할 때 테스트를 실행할 것이다.
- 테스트는 프로그래머를 위한 묘석인데, 두려움을 지루함으로 바꿔주는 효험이 있다.
- 테스트를 실행하면 즉시 좋은 느낌을 받게 되고 (초록 막대를 보았을 시) 그러면 작업 중에 에러를 낼 일도 줄게 되며, 스트레스도 적어진다.

### 격리된 테스트
> 테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가?
- 아무 영향이 없어야 한다.

> 경험에서 얻은 두 가지 교훈
- 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자는 것
- 어마어마한 양의 종이더미가 반드시 어마어마한 양의 문제를 의미하는 것은 아니라는 점
- 테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다
- 각각의 테스트는 다른 테스트와 완전히 독립적이어야 한다는 것
- 즉, 문제가 하나면 테스트도 하나만 실패해야 하고, 문제가 둘이면 테스트도 두 개만 실패해야 한다.

> 격리된 테스트가 암묵적으로 내포하는 특징 중 하나는 테스트가 실행 순서에 독립적이게 된다는 점이다.
- 테스트의 일부만 실행해보고 싶으면, 선행 테스트가 실행되지 않아서 내가 고른 테스트들이 실패하지 않을까 걱정할 필요 없이 그렇게 할 수 있어야 한다.

> 격리된 테스트가 내포하는 것
- 주어진 문제를 작은 단위로 분리하기 위해 노력해서 각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다는 것
- 테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.

### 테스트 목록
> 뭘 테스트해야 하나?
- 시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것.
- 프로그래밍 스트레스를 줄이기 위한 우리 접근법의 첫 단계는 발 디딜 곳이 확실해지기 전엔 결코 발을 떼어 전진하지 말자는 것이다.

> 목표에서 벗어나지 않고 집중할 수 있는 한 가지 전략은 모든 걸 머릿속에 넣어두는 것
- 경험이 축적될수록 할일 목록이 많아진다.
- 할일 목록이 많아질수록 내가 하던 일에 대한 집중력이 떨어지고 성취도는 낮아진다.
- 성취도가 낮아지면 할일 목록은 더 많아진다.
- 그냥 머릿속에 있는 목록에서 임의의 항목을 무시하고 변덕스럽게 프로그래밍해 봤지만, 이 고리를 깨지는 못했다.

> 향후 몇 시간 내로 해치워야 하는 모든 할일 목록을 컴퓨터 옆에 있는 종이 조각에 적어놓는 습관을 가지자
- 주 혹은 월 단위 목록도 만들어서 벽에 붙여둔다.
- 이걸 다 적기만 하면 앞으로는 할일을 놓치지 않게 될 것이다.
- 새로운 항목이 나타나면 나는 빠르고 의식적으로 이 항목이 '지금' 할일에 속하는지 '나중에' 할일에 속하는지, 또는 할 필요가 없는 일인지를 결정한다.

> 이를 테스트 주도 개발에 적용해보면, 구현해야 할 것들에 대한 테스트를 목록에 적게 된다.
- 우선 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.
- 그 다음, 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전(아무 일도 하지 않는 버전)을 리스트에 적는다.
- 마지막으로 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야할 리팩토링 목록을 적는다.

> 테스트를 한번에 다 만들어 놓는 방법이 먹히지 않았던 이유
- 만들어진 모든 테스트는 리팩토링에 대해 약간의 관성을 갖는다.
    - 자동화된 리팩토링 도구(예를 들어 변수의 선언부와 모든 참조를 찾아서 한번에 이름 바꾸기를 수행해 주는 메뉴 항목 같은 것)가 있다면 별 문제가 되지 않는다.
    - 그렇지 않다면 열 개의 테스트를 만든 후에 매개 변수의 순서를 반대로 하는 게 좋을 거라는 사실을 발견하더라도 아마 이 순서를 바꾸지 않으려 할 것이다.
- 열 개의 테스트가 실패했다면 초록 막대를 보는 것은 한참 멀었다.
    - 빨리 초록막대를 볼 방법은 열 개의 테스트를 몽땅 지워버리는 것 뿐이다.
    - 만약 모든 테스트가 통과하도록 하려면 오랫동안 빨간 막대 상태에 머물러야 한다.
    
> 테스트를 통과하게 만드는 과정에서 여러분이 작성한 코드들은 새로운 테스트가 필요함을 암시적으로 알려줄 것이다. 이 새 테스트를 리팩토링과 마찬가지로 할일 목록에 적어 놓아라.

- 제대로 작동하지 않는 테스트를 하나라도 생각할 수 있다면, 그걸 제대로 되게 하는 것이 코드를 릴리즈 하는 것보다 더 중요하다.

### 테스트 우선
> 테스트를 언제 작성하는 것이 좋을까?
- 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.

> 코드를 작성한 후에는 테스트를 만들지 않을 것이다.
- 프로그래머로서의 목표는 기능이 실행되도록 만드는 것이다.
- 하지만 한편으로는 프로그램의 설계에 대해 생각해볼 시간도 필요하고 작업 범위를 조절할 방법도 필요할 것이다.

> 테스트를 먼저 해야 한다는 규칙을 도입하자
- 영향도를 뒤집을 수 있고 효과적인 주기를 만들어내게 된다.
- 테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다.

### 단언 우선
> 테스트를 작성할 때 단언(assert)은 언제쯤 쓸까?
- 단언을 제일 먼저 쓰고 시작하라. 자기유사성(self-similarity)란 참 멋지지 않은가?

- 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다.
  - 통상 자그마한 인덱스 카드 한 장에 하나의 스토리를 기록한다.
- 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.
- 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

> 단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다.
- 테스트만 작성할 때도 사실 여러분은 몇 가지 문제들을 한번에 해결하는 것이다.
  - 테스트하고자 하는 기능이 어디에 속하는 걸까? 기존의 메서드를 수정해야 하나, 기존의 클래스에 새로운 메서드를 추가해야 하나, 아니면 이름이 같은 메서드를 새 장소에? 또는 새 클래스에?
  - 메서드 이름을 뭐라고 해야 하나?
  - 올바른 결과를 어떤 식으로 검사할 것인가?
  - 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?
- 이 많은 문제를 한번에 잘 해결하기엔 문제가 좀 있다. 이 중 "올바른 결과는 무엇인가?", "어떤 식으로 검사할 것인가?"는 나머지 문제에서 쉽게 분리할 수 있다.

> 소켓 통신 예시
- 소켓을 통해 다른 시스템과 통신하려 한다고 가정하자.
- 통신을 마친 후 소켓은 닫혀 있고, 소켓에서 문자열 'abc'를 읽어와야 한다고 치자
```java
testCompleteTransaction() {
    ...
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- reply는 어디서 얻어오나? 물론 socket이다.
```java
testCompleteTransaction() {
    ...
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 그럼 socket은 어디에서 나오나? 서버에 접속할 때 생성된다.
```java
testCompleteTransaction() {
    ...
    Socket reader= Socket("localhost", defaultPort());
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 물론 이 작업을 하기 전에 서버를 먼저 열어야 한다.
```java
testCompleteTransaction() {
    Server writer= Server(defaultPort(), "abc")
    Socket reader= Socket("localhost", defaultPort());
    Beffer reply= reader.contents();    
    assertTrue(reader, isClosed());
    assertEquals("abc", reply.contents());
}
```
- 아직 실제 용도에 맞게 이름을 수정하는 일이 남아 있긴 하지만 지금까지 아주 작은 단계로 빠른 피드백을 받으며 테스트의 아웃라인을 만들었다.


### 테스트 데이터
> 테스트할 때 어떤 데이터를 사용해야 하는가?
- 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용해라.
- 테스트 작성에도 청중이 존재한다.
- 단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라.
- 데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야 한다.
- 1과 2 사이에 어떠한 개념적 차이점도 없다면 1을 사용하라.
- 만약 시스템이 여러 입력을 다루어야 한다면 테스트 역시 여러 입력을 반영해야 한다. 하지만 세 항목만으로 동일한 설계와 구현을 이끌어낼 수 있다면 굳이 항목을 열 개나 나열할 필요는 없다.

> 테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다.
- 만약 plus() 메서드를 구현하려고 한다면 고전적 예제인 2+2 혹은 1+1을 쓰고 싶을 것이다.
- 만약 구현에서 인자의 순서가 뒤집힌다면 어떻게 될까?
  - plus()에서야 순서가 뒤집혀도 상관이 없겠지만...
- 우리가 첫 번째 인자로 2를 썼다면 두 번째 인자는 3을 써야 한다.

> 테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다.
> 실제 데이터는 다음과 같은 경우에 유용하다.
- 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
- 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우(병렬 테스팅).
- 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우.
  - 특히 부동소수점 값의 정확성이 문제가 될 수 있다.
  
### 명백한 데이터
> 데이터의 의도를 어떻게 표현할 것인가?
- 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.

> 통화 환전 예시
- 한 통화를 다른 통화로 환전하려고 하는데, 이 거래에는 수수료 1.5%가 붙는다.
- USD에서 GBP로 교환하는 환율이 2:1이라면 $100를 환전하려면 50GBP - 1.5% = 49.25GBP여야 한다.
```java
Bank bank= new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result= bank.convert(new Note(100, "USED"), "GBP");
assertEquals(new Note(49.25, "GBP"), result);
```
- 또는 계산을 더 명확히 표현할 수도 있다.
```java
Bank bank= new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result= bank.convert(new Note(100, "USED"), "GBP");
assertEquals(new Note(100 / 2 * (1 - 0.015), "GBP"), result);
```
- 이 테스트에서는 입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 읽어낼 수가 있다.

> 명백한 데이터가 주는 또 다른 이점
- 프로그래밍이 더 쉬워진다.
- 단언 부분에 일단 수식을 써놓으면 다음으로 무엇을 해야 할지 쉽게 알게 된다.
- 이런 경우 어떻게든 나눗셈과 곱셈을 수행할 프로그램을 만들어야 한다는 걸 알게 되는 것이다.
- 이 오퍼레이션이 어디에 속할지를 점진적으로 알아내기 위해 가짜 구현을 해볼 수도 있다.

## 26장 빨간 막대 패턴
- 이 패턴들은 테스트를 언제 어디에 작성할 것인지, 테스트 작성을 언제 멈출지에 대한 것이다.

### 한 단계 테스트
> 목록에서 다음 테스트를 고를 때 무엇을 기준으로 할 것인가?
- 여러분에게 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것.
- 각 테스트는 여러분을 최종 목표로 한 단계 진전시켜 줄 수 있어야 한다. 다음 테스트 목록 중 무엇을 고르는게 좋을까?
  - 더하기
  - 빼기
  - 곱하기
  - 나누기
  - 비슷한 것 더하기
  - 동치성(equals)
  - 널과의 동치성(equals null)
  - 널 환전
  - 한 개의 통화를 환전하기
  - 두 개의 통화를 환전하기
  - 환시세
- 정답은 없다. 내가 이런 걸 한번도 만들어 보지 않았다고 치면, 내게 한 단계의 크기는 경험이 풍부한 여러분의 한 단계에 비해 1/10 정도일 것이다.
- 이 목록에서 한 단계 전진을 나타낼 만한 것을 못 찾았다면 직접 하나 추가해 보기 바란다

> 테스트 목록을 볼 땐 보통 이런 식이다.
- "이건 뻔하지, 이것도 뻔하고, 이건 잘 모르겠군, 이건 뻔하고, 이건... 내가 무슨 생각으로 적은 거지? 아, 이건 할 수 있겠다."
- 이 마지막 테스트가 바로 내가 다음으로 구현할 테스트인 것이다.
- 뻔하진 않지만 구현할 수 있다는 확신이 있다.

- 전체 계산 중 간단한 하나의 사례를 나타내는 테스트에서 시작했다면
  - 이 테스트를 통해 자라는 프로그램은 하향식(top-down)으로 작성된 것
- 반면 전체의 작은 한 조각을 나타내는 테스트에서 시작하여 조금씩 붙여나가는 식이었다면
  - 이 프로그램은 상향식(bottom-up)으로 작성된 것으로 보일 수도 있다.
  
> 사실은 상향식, 하향식 둘 다 TDD의 프로세스를 효과적으로 설명해 줄 수 없다.
- 첫째로 이와 같은 수직적 메타포는 프로그램이 시간에 따라 어떻게 변해 가는지에 대한 단순화된 시각일 뿐이다.

> 이보다 성장(growth)이란 단어를 보자.
- '성장'은 일종의 자기유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.
- 둘째로, 만약 메타포가 어떤 방향성을 가질 필요가 있다면 (상향 혹은 하향보다는)
  - '아는 것에서 모르는 것으로(known-to-unknown'라는 방향이 유용할 것이다.
  - 이는 우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.
- 우리는 아는 것에서 모르는 것으로 성장하는 프로그램을 갖게 된다.

### 시작 테스트
> 어떤 테스트부터 시작하는 게 좋을까?
- 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트할 것.
- 새 오퍼레이션에 대한 첫 질문은 다음과 같을 것이다.
  - "이 오퍼레이션을 어디에 넣어야 하지?"
- 이 질문에 답하기 전까지는 테스트에 뭘 적어야 할 지 알 수 없을 것이다.
- 한 번에 한 문제만 해결하자는 의미에서 다른 질문은 다 빼고 딱 이 질문만 생각할 방법은 무엇인가?

> 첫 걸음으로 현실적인 테스트를 하나 작성한다면 상당히 많은 문제를 한번에 해결해야 하는 상황이 될 것이다.
- 이 오퍼레이션을 어디에 두어야 하나?
- 적절한 입력 값은 무엇인가?
- 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

> 현실적인 테스트 하나로 시작하면 너무 오랫동안 피드백이 없을 것이다.
- 빨강/초록/리팩토링, 빨강/초록/리팩토링. 여러분은 이 고리가 몇 분 내에로 반복되길 원할 것이다.

> 정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.
- 예를 들어 XP 뉴스그룹에 누군가가 다각형 축소기(polygon reducer)를 테스트 우선으로 어떻게 작성할지 질문했다.
- 입력은 다각형 그물이고, 출력은 정확하게 똑같은 표면이면서 가능한 한 최소 개수의 다각형으로 구성된 다각형 그물이 된다.
- "테스트를 작동하도록 하는 데 박사 학위 논문을 읽어야 하는 경우, 이 문제를 어떻게 테스트 주도로 접근할 수 있을까요?"

> 시작 테스트 패턴이 이 문제에 대한 답을 준다.
- 출력이 입력과 같은 경우가 있다. 어떤 형상(configuration)의 다각형들은 이미 정규화되어 있고 더 축소할 수 없다.
- 입력은 가능한 한 적어야 한다. 이를테면 다각형 하나 또는 아예 비어있는 다각형 목록일 수 있다.
- 다음 시작 테스트를 작성했다.
```java
Reducer r= new Reducer(new Polygon());
assertEquals(0, reducer.result().npoints);
```
- 짠! 첫 번째 테스트가 돌아간다. 이제 목록에 있는 나머지 테스트를 처리할 차례다.

> 한 단계 테스트는 시작 테스트에도 적용된다. 
- 당신에게 뭔가를 가르쳐줄 수 있으면서도 빠르게 구현할 수 있는 테스트를 선택하라.
- 만약 당신이 어떤 애플리케이션을 n번째 구현하고 있다면, 오퍼레이션을 한두 개 필요로 하는 테스트를 하나 골라라.
- 당신은 그걸 작동하게 할 수 있을 거라 자신할 것이다.
- 만약 뭔가 어렵고 복잡한 것을 처음 구현해보고 있다면 당신은 즉각 조그만 용기의 알약을 하나 먹어야 한다.
- 많은 경우 나의 시작 테스트는 그 이후의 테스트에 비해 좀더 높은 차원의 테스트로, 애플리케이션 테스트와 비슷하다.
- 내가 자주 테스트 주도로 개발하는 예 중 하나는 간단한 소켓 기반 서버이다.
- 첫 번째 테스트
```java
StartServer
Socket= new Socket
Message= "hello"
Socket.write(message)
AssertEquals(message, socket.read)
```
- 이제 나머지 테스트는 서버만으로 이루어질 수 있다. 
- "우리가 이런 문자열을 받았다고 치고...."

### 설명 테스트
> 자동화된 테스트가 더 널리 쓰이게 하려면 어떻게 해야 할까?
- 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라.
- 팀에서 혼자 TDD를 한다면 꽤나 어려움을 느낄 수도 있다.
- 하지만 머지않아, 테스트된 코드의 통합 문제와 결함 보고가 줄어드는 것을 팀에서 알아챌 것이고, 설계는 더 단순해지고 설명하기에 용이해질 것이다.
- 심지어 사람들이 테스트와 테스트 우선에 정말 열광적이게 되는 일이 발생할 수 있다.

### 학습 테스트
> 외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있을까?
- 패키지의 새로운 기능을 처음으로 사용해보기 전에 작성할 수 있다.

- 자바의 모바일 정보 기기 프로파일 라이브러리를 기반으로 뭔가를 만들어야 한다고 치자.
- Record-Store에 어떤 데이터를 저장하고 이를 받아오고자 한다.
- 그냥 코딩하고선 그게 잘 돌아가길 바라는 게 좋을까? 그것도 한 방법이긴 하다.

> 한 가지 대안은 우리가 이제 막 새 클래스의 새 메서드를 하나 사용한다는 것을 알아채는 것이다.
- 그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다.

```java
public void setUp() {
    store= RecordStore.openRecordStore("testing", true);    
}

public void tearDown() {
    RecordStore.deleteRecordStore("testing");
}

public void testStore() {
    int id= store.addRecord(new byte[] {5, 6}, 0, 2);
    assertEquals(2, store.getRecordSize(id));
    byte[] buffer= new byte[2];
    assertEquals(2, store.getRecord(id, buffer, 0));
    assertEquals(5, buffer[0]);
    assertEquals(6, buffer[1]);
}
```
- 만약 우리가 API를 제대로 이해했다면 이 테스트는 한번에 통과할 것이다.
- 패키지의 새 버전이 도착하면 우선 테스트를 실행한다. (그리고 필요하다면 수정한다.)
- 만약 테스트가 통과되지 않는다면 애플리케이션 역시 실행되지 않을 것이 뻔하기 때문에 애플리케이션을 실행해볼 필요도 없다.
- 일단 테스트가 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다.

### 또 다른 테스트
> 어떻게 하면 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있을까?
- 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아올 것.
- 대화를 엄격하게 한 주제로 묶는 것은 훌륭한 아이디어를 억압하는 최고의 방법이다.
- 이리 저리 건너뛰어 다니다가 "도대체 어쩌다 이런 얘길 하고 있는거지? 무슨 상관이람, 이거 참 좋은 아이디어인데!" 하고 생각하는 것이다.

> 새 아이디어가 떠오르면 존중하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다.
- 그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다.

### 회귀 테스트
> 시스템 장애가 보고될 때 여러분은 무슨 일을 제일 먼저 하는가?
- 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라.

> 회귀 테스트란,(regresstion test)
- 처음 코딩할 때 작성했어야 하는 테스트다.
- 회귀 테스트를 작성할땐 이 테스트를 작성해야 한다는 사실을 어떻게 하면 애초에 알 수 있었을지 항상 생각해보라.
- 애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 여러분에게 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다.
- 좀더 작은 차원에서 회귀 테스트는 당신의 테스트를 개선하는 방법이된다.
- 기괴할 정도로 큰 음수에 대한 결함보고서가 있을 수 있다.
- 여기에서는 테스트 목록을 작성할 때 정수 롤오버를 테스트할 필요가 있다는 것을 배울 수 있다.

> 시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야 한다.
- 이러한 종류의 장애가 있다는 것은, 시스템이 여러분에게 다음과 같은 말을 한다는 뜻이다.
- "아직 내 설계를 마무리 못했구먼."


### 휴식
> 지치고 고난에 빠졌을 땐 뭘 해야 하나? 
- 그럴 땐 좀 쉬는게 좋다.

> 데이브 웅가(Dave Ungar)의 샤워 방법론
- 키보드로 뭘 쳐야 할지 알면, 그걸 치면 된다.
- 뭘 해야 할지 모르겠으면 샤워하러 가서 뭘 해야 할지 생각날 때까지 계속 샤워를 한다.
- TDD는 웅가의 샤워 방법론을 정제한 것이다.
- 키보드로 뭘 쳐야 할지 알면, 명백한 구현을 한다.
- 잘 모르겠다면 가짜 구현을 한다.
- 올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다.


### 다시 하기
> 길을 잃은 느낌이 들 땐 어떻게 해야 할까?
- 코드를 다 지워버리고 처음부터 다시 해보자.


## 27장 테스팅 패턴
- 이 패턴들은 더 상세한 테스트 작성법에 대한 것이다.

### 자식 테스트
> 지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까?
- 원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라. 그 후에 다시 원래의 큰 테스트 케이스를 추가하라.

- 빨강/초록/리팩토링 리듬은 성공시 지속되는 데 너무나도 중요해서, 그 리듬을 잃어버릴 것 같은 위기 순간에 부가의 노력으로 리듬을 유지하는 것이 충분히 가치 있다.
- 나의 경우, 테스트를 만들어놓고 보니 막상 이걸 통과시키려면 몇 가지를 한번에 수정해야만 하는 때에 이런 위기의 순간이 생기는데, 단 10분간만 빨간색이 지속되어도 겁이 난다.

> 나는 큰 테스트를 작성하고 나면 우선 교훈을 찾기 위해 노력한다.
- 왜 테스트가 그렇게 컸을까?
- 어떤 다른 방식을 취했더라면 좀더 작게 만들 수 있었을까?
- 지금 내 느낌은 어떤가?

> 나 자신을 형이상학적으로 바라볼 수 있게 되면, 거슬리는 테스트를 삭제하고 다시 시작한다.
- "음, 이 세가지를 한번에 동작하게 하려면 할일이 너무 많겠군. A를 동작하게 만든 후에 B를, 그 다음에 C를 동작하게 만들면 전체가 제대로 동작할 거 같군."
- 때로는 진짜로 테스트를 지워버리기도 하고, 또는 메서드 이름 앞에 x를 추가해서 실행만 되지 않게 하기도 한다.
- 두가지 모두 시도해 보기 바란다. 테스트 두 개가 깨진 상황에서는 어떤 다른 느낌이 드는지, 스스로 어떤 다른 방식으로 코딩하는지 관찰해 보고 적절한 방식을 선택하라.

### 모의 객체
> 비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야 할까?
- 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다.

> 모의 객체(Mock Object)
- 모의 객체의 고전적인 예는 데이터베이스다.
- 데이터베이스는 시작 시간이 오래 걸리고, 깨끗한 상태로 유지하기가 어렵다.
- 그리고 만약 데이터베이스가 원격 서버에 있다면 이로 인해 테스트 성공 여부가 네트워크 상의 물리적 위치에 영향을 받게 된다.
- 또한 데이터베이스는 개발 중 많은 오류의 원인이 된다.
- 해법은 대부분의 경우에 진짜 데이터베이스를 사용하지 않는 것이다.
- 대다수의 테스트는, 마치 데이터베이스인 것처럼 행동하지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다.

```java
public void testOrderLookup() {
    Database db= new MockDatabase();
    db.expectQuery("select order_no from Order where cust_no is 123");
    db.returnResult(new String[] {"Order 2", "Order 3"});
    ...
}
```
- MockDatabase는 예상된 쿼리를 얻지 못하면 예외를 던질 것이다.
- 만약 쿼리가 올바르다면 MockDatabase는 상수 문자열에서 마치 결과 집합(result set)처럼 보이는 뭔가를 생성하여 반환한다.

> 성능과 견고함 이외에 모의 객체의 또 다른 가치는 가독성에 있다.
- 당신은 앞서 나온 테스트를 끝에서 끝까지 읽을 수 있다.
- 만약 사실적인 데이터로 가득 찬 테스트 데이터베이스를 사용한다면, 어떤 쿼리가 결과 14개를 되돌려야 한다고 적은 테스트를 보더라도
도대체 왜 14개가 올바른 답인지 알기가 쉽지 않다.
- 만약 모의 객체를 사용하길 원한다면, 값비싼 자원을 전역 변수에 손쉽게 저장해 버릴 수는 없다.
- 만약 그렇게 한다면, 전역 변수를 모의 객체로 설정하고, 테스트를 실행한 후 다시 전역 변수를 복구시켜 놓아야 한다.

> 마시모 아놀디와 함께 전역 변수에 저장된 환율 집합을 이용하는 코드를 가지고 작업할 때
- 각각의 테스트는 데이터의 서로 다른 부분 집합을 필요로 했고, 종종 서로 다른 환율이 필요한 경우도 있었다.
- 전역 변수를 가지고 어떻게든 해보려고 어느 정도 시도한 끝에, 어느 날 아침 환율 객체인 Exchange를 필요로 하는 모든 곳에 전달하기로 했다.
- 우린 수백 개의 메서드를 변경해야 할 것이라고 생각했다.
- 끝날 무렵, 우리는 약 10개 ~ 15개 메서드에 인자를 추가했고, 그러는 와중에 기타 다른 설계 문제도 깨끗이 정리했다.

> 모의 객체는 설계에서 커플링이 감소하도록 한다.
- 모의 객체는 당신이 모든 객체의 가시성(visibility)에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다.
- 모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가된다.
- 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까?
- 모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다.


### 셀프 션트
> 한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까?
- 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트 케이스와 대화하도록 만들면 된다.

> 테스팅 사용자 인터페이스의 초록 막대를 동적으로 업데이트하고자 하는 상황을 가정해 보자.
- UI 객체를 TestResult와 연결할 수 있다면 테스트가 실행된 시점, 테스트가 실패한 시점, 전체 테스트 슈트가 시작되고 끝난 시점 등을 통보 받을 수 있을 것이다.
- 그리고 이러한 이벤트를 통보받으면 인터페이스를 갱신하면 된다.

```python
## ResultListenerTest
def testNotification(self) :
    result= TestResult()
    listener= ResultListener()
    result.addListener(listener)
    WasRun("testMethod").run(result)
    assert 1 == listener.count
```
- 이 테스트가 수행되려면 이벤트 통보 횟수를 셀 객체가 필요하다.

```python
## ResultListener
class ResultListener:
    def __init__(self):
        self.count= 0
    def startTest(self):
        self.count= self.count + 1
```
- 잠깐 그런데 왜 이벤트 리스너를 위해 별도의 객체를 만들어야 하는 걸까?
- 그냥 테스트 케이스 자체를 리스너로 쓰면 될 텐데 말이다.
- 즉 테스트 케이스가 일종의 모의 객체 노릇을 하는 것이다.
```python
## ResultListenerTest
def testNotification(self):
    self.count= 0
    result= TestResult()
    result.addListener(self)
    WasRun("testMethod").run(result)
    assert 1 == self.count
def startTest(self):
    self.count= self.count + 1
```
- 셀프 션트 패턴을 이용해 작성한 테스트가 그렇지 않은 테스트보다 읽기에 더 수월하다.
- 위의 테스트가 좋은 예다.
- 통보 횟수가 0이었다가 1로 됐다.
- 이 순서를 테스트에서 바로 읽어낼 수 있다.
- 어떻게 횟수가 1이 될 수 있었을까?
- 누군가 startTest()를 호출했을 것이다.
- startTest()는 어떻게 해서 호출됐는가?
- 테스트가 실행될 때 호출된다.
- 이것은 대칭성의 또다른 예다.
- 두 번째 버전의 테스트 메서드는 통보 횟수에 대한 두 값이 한 곳에 모여 있는 반면,
- 첫 번째 버전의 테스트 메서드에서는 하나의 클래스에서 횟수를 0으로 설정하고 다른 클래스에서 1이 예상치임을 나타낸다.

> 셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출을 해야 한다.
- 인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 당신이 결정해야 할 것이다.
- 하지만 내가 언급한 바와 같이 셀프 션트를 위해 추출해 낸 인터페이스는 여러 곳에서 쓰이는 경우가 많다.
- 자바의 경우, 셀프 션트를 사용한 결과로 인터페이스 안의 온갖 기괴한 메서드들을 다 구현한 테스트들을 보게 될 것이다.
- 자바에서는 빈 메서드로라도 인터페이스의 모든 오퍼레이션들을 구현해야 한다.


### 로그 문자열
> 메시지의 호출 순서가 올바른지를 검사하려면 어떻게 해야 할까?
- 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다.

> xUnit에서 쓴 예제
- setUp(), 테스트를 수행하는 메서드, tearDown() 순서로 호출되길 원하는 템플릿 메서드(Template Method()가 있다.
- 각 메서드들이 로그 문자열에 자기 이름을 추가하게 구현하면 쉽게 읽히는 테스트를 만들 수 있다.
```python
def testTemplateMethod(self):
    test= WasRun("testMethod")
    result= TestResult()
    test.run(result)
    assert("setUp testMethod tearDown " == test.log)
```
- 구현 또한 간단하다.
```python
## WasRun
def setUp(self):
    self.log= "setUp "
def testMethod(self):
    self.log= self.log + "testMethod "
def tearDown(self):
    self.log= self.log + "tearDown "
```
- 로그 문자열은 특히 옵저버를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다.
- 만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없을 경우엔
- 문자열 집합을 저장하고 있다가 단언(assertion)에서 집합 비교를 수행하면 된다.
- 로그 문자열은 셀프 션트와도 잘 작동한다. 해당 테스트 케이스는 로그를 추가하고 적절한 값을 반환하는 식으로 셀프 션트한 인터페이스의 메서드를 구현한다.

### 크래시 테스트 더미
> 호출되지 않을 것 같은 에러 코드(발생하기 힘든 에러 상황)을 어떻게 테스트할 것인가?
- 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다.
- 테스트되지 않은 코드는 작동하는 것이 아니다. 이것이 안전한 가정 같다.
- 그렇다면 수많은 에러 상황에 대해서는 어떻게 테스트할 것인가? 
- 이것들도 다 테스트해야 할까? 작동하길 원하는 부분에 대해서만 하면 된다.

> 파일 시스템에 여유 공간이 없을 경우 발생할 문제에 대해 테스트하기를 원할때
- 실제로 큰 파일을 많이 만들어서 파일 시스템을 꽉채우기
- 가짜 구현(fake it) 사용하기 ✔
- 파일을 위한 크래시 테스트 더미(Crash Test Dummy)는 다음과 같다.
```java
private class FullFile extends File {
    public FullFile(String path) {
        super(path);
    }
    public boolean createNewFile() throws IOException {
        throw new IOException();
    }
}
```
- 이제 다음과 같이 예상되는 예외를 테스트할 수 있다.
```java
public void testFileSystemError() {
    File f= new FullFile("foo");
    try {
        saveAs(f);
        fail();
    } catch (IoException e) {
        
    }
}
```
- 객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.
- 자바의 익명 내부 클래스 (anonymous inner class)는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생시키게끔 하기 위해 유용하게 쓰인다.
- 테스트 케이스 안에서 원하는 메서드 하나만 재정의할 수 있다. 이렇게 하면 테스트 읽기가 수월해진다.

```java
public void testFileSystemError() {
    File f= new File("foo") {
        public boolean createNewFile() throws IOException {
            throw new IOException();
        }
    };
    try {
        saveAs(f);
        fail();
    } catch (IOException e) {
    }
}
```

### 깨진 테스트
> 혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?
- 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.
- 다음에 다시 글을 쓰기 위해 앉았을 때, 반 쪽짜리 문장을 보면 전에 그 문장을 쓸 때 무슨 생각을 했는지 떠올리게 된다.
- 일단 생각의 실마리를 다시 떠올리고 나면 문장을 마무리하고 계속 진행할 수 있다.
- 전에 하고 있던 생각에 대한 명확하고 구체적인 책갈피를 가지게 되는 것이다.
- 깨진 테스트 하나가 있다고 해서 프로그램 완성도가 더 떨어지는 것은 아니며, 단지 프로그램의 상태를 드러나게 해줄 뿐이다.
- 몇 주간의 간극 후에 개발하던 것을 그대로 이어나갈 수 있는 능력을 위해서는 빨간 막대를 놔두고 가버리는 데서 오는 약간의 가책 정도는 감수할 수 있다.


### 깨끗한 체크인
> 팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?
- 모든 테스트가 성공한 상태로 끝마치는 것이 좋다.
- 다른 팀원들과 함께 작업하는 경우라면 상황은 완전히 달라진다.
- 팀 프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다.
- 안심이 되고 확신이 있는 상태에서 시작할 필요가 있다.
- 따라서 체크인하기 전에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다.

> 때론 테스트 슈트에서 테스트가 실패하는 경우도 있을 것이다. 어떻게 해야 할까?
- 가장 단순한 규칙은 그동안 작업한 코드를 날려버리고 다시 하는 것이다.
- 실패한 테스트는 방금 여러분이 만들어 낸 프로그램을 여러분이 완전히 이해하지 못했음을 말해주는 강력한 증거다.
- 이 방법보다 아주 약간 방탕해 보이는 접근은, 문제를 수정하고 테스트를 다시 실행해보는 것이다.
- 통합 자원을 독차지 하는 것을 피하기 위해, 아마도 몇 분 후에는 그냥 포기해버리고 다시 시작해야 할 것이다.


## 28장 초록 막대 패턴
- 깨진 테스트가 있다면 그걸 고쳐야 한다. 빨간 막대를 가능한 한 빨리 고쳐야 하는 조건으로 다룬다면 당신은 금세 초록 막대로 옮겨갈 수 있다는 것을 깨닫게 될 것이다.
- 코드가 테스트를 통과하게 만들기 위해 이 패턴들을 사용해라

### 가짜로 구현하기(진짜로 만들기 전까지만)
> 실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는 게 좋을까?
- 상수를 반환하게 하라.
- 일단 테스트가 통과하면 단계적으로 상수를 변수를 사용하는 수식으로 변형한다.
- xUnit을 구현하는 과정에서의 예제
```python
return "1 run, 0 failed"
```
- 이 코드가 다음과 같이 변하고
```python
return "%d run, 0 failed" % self.runCount
```
- 이 코드가 다음과 같이 변한다.
```python
return "%d run, %d failed" % (self.runCount, self.failureCount)
```
- 가짜로 구현하기는 등산할 때 피톤을 머리 위에 박아두는 것과 비슷하다.
- 아직 그곳에 도달하지는 못했다. (테스트가 통과하긴 하지만 코드 구조가 잘못된 상태)
- 하지만 그곳에 도달하면 안전할 것임을 안다(여전히 테스트가 통과할 것이다).

> 가짜로 구현하기를 강력하게 만드는 두 가지 효과
- 심리학적 - 막대가 초록색일 때, 자신이 어디에 서 있는지 안다. 당신은 확신을 갖고 거기부터 리팩토링해 갈 수 있다.
- 범위(scope) 조절 - 하나의 구체적인 예에서 시작해서 일반화하게 되면, 쓰잘데기 없는 고민으로 때 이르게 혼동하는 일을 예방할 수 있다. 이전 테스트의 작동이 보장된다는 것을 알기 때문에 그 다음 테스트 케이스에도 집중할 수 있다.

> 필요 없는 코드는 조금도 작성하지 말라는 법칙에 가짜로 구현하기가 위배되는가?
- 리팩토링 단계에서 테스트 케이스와 코드 간의 데이터 중복을 제거하기 때문에 위배되지 않는다.
- 내가 다음 코드를 작성할때
```java
assertEquals(new MyDate("28.2.02"), new MyDate("1.3.02").yesterday());
// MyDate
public MyDate yesterday() {
    return new MyDate("28.2.02");
}
```
- 테스트와 코드 간에 중복이 있다. 다음과 같이 작성해서 그 중복을 옮길 수 있다.
```java
// MyDate
public MyDate yesterday() {
    return new MyDate(new MyDate("1.3.02").days()-1);
}
```
- 하지만 여전히 중복이 있다. 그러나 데이터 중복을 다음과 같이 제거할 수 있다.
- (내 테스트의 목적상, this가 MyDate("1.3.02")와 같기 때문에)
```java
// MyDate
public MyDate yesterday() {
    return new MyDate(this.days()-1);
}
```
- 모두가 이런 궤변을 확신하지는 않는데, 그런 경우 최소한 질릴 때까지는 삼각측량을 사용하고, 가짜로 구현하기나 심지어는 명백한 구현을 사용하기 시작할 수 있다.


### 삼각측량
> 추상화 과정을 테스트로 주도할 때 어떻게 최대한 보수적으로 할 수 있겠는가?
- 오로지 예가 두 개 이상일 때에만 추상화를 하라.
- 두 정수의 합을 반환하는 함수를 작성하고 싶다고 가정하자.
```java
public void testSum() {
    assertEquals(4, plus(3, 1));
}

private int plus(int augend, int addend) {
    return 4;
}
```
- 삼각측량(triangulate)을 사용해서 바른 설계로 간다면 다음과 같이 작성해야 한다.
```java
public void testSum() {
    assertEquals(4, plus(3, 1));
    assertEquals(7, plus(3, 4));
}
```
- 우리가 두 번째 예를 얻었을 때 plus()의 구현을 추상화할 수 있다.
```java
public int plus(int augend, int addend) {
    return augend + addend;    
}
```
- 삼각측량이 매력적인 이유는 그 규칙이 매우 명확하기 때문이다.
- 두 단언이 있고 plus를 위한 바른 구현을 추상화했다면, 두 단언 중 하나를 삭제할 수 있는데 그것이 다른 하나와 완전히 중복되기 때문이다.
- 하지만 그렇게 하면 우리는 plus()의 구현을 단순히 상수를 반환하는 것으로 단순화할 수 있는데 그렇게 되면 다시 단언 하나를 추가해야 한다.
- 나는 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 정말 감잡기 어려울 때만 삼각측량을 사용한다.

### 명백한 구현
> 단순한 연산들을 어떻게 구현하는가?
- 그냥 구현해 버려라.

- 가짜로 구현하기와 삼각측량은 눈곱만큼 작은 발걸음이다.
- 때때로 어떤 연산을 어떻게 구현해야 할지 확신이 들기도 한다. 그럼 그렇게 하라!
- 예를 들어 plus() 만큼 간단한 것을 구현할 때 내가 정말 가짜로 구현하기를 사용할까?
- 보통은 그렇게 하지 않는다. 나는 그냥 명백한 구현을 입력하고 만약 빨간 막대를 본다면 그제서야 좀더 작은 발걸음으로 옮겨갈 것이다.
- 뭘 타이핑해야 할지 알고, 그걸 재빨리 할 수 있다면 그냥 해버려라.
- '제대로 동작하는'을 푸는 동시에 '깨끗한 코드'를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다.
- 그렇게 되면 '제대로 동작하는'으로 되돌아 가서 그걸 해결하고, 그 후에 '깨끗한 코드'를 느긋하게 해결하도록 하라.

> 당신은 빨강/초록/리팩토링의 리듬을 유지하길 원한다. 명백한 구현은 두번째 기어다.
> 만약 손가락이 머리를 따라오지 못하기 시작하면 저속 기어로 전환할 준비를 하라.


### 하나에서 여럿으로
> 객체 컬렉션(collection)을 다루는 연산은 어떻게 구현하나?
- 일단은 컬렉션 없이 구현하고 그 다음에 컬렉션을 사용하게 한다.
- 숫자 배열의 합을 구하는 함수 예제
- 일단은 하나로 시작한다.
```java
public void testSum() {
    assertEquals(5, sum(5));
}
private int sum(int value) {
    return value;
}
```
- (나는 sum()을 TestCase 클래스에서 구현해서, 단지 한 메서드를 위해 새 클래스를 작성하는 것을 피하고 있다.)
- 다음에는 sum(new int[] {5, 7})을 테스트하고 싶다. 우선은 sum()에 배열을 받아들이는 인자를 하나 추가한다.
```java
public void teamSum() {
    assertEquals(5, sum(5, new int[] {5}));
}
private int sum(int value, int[] values) {
    return value;
}
```
- 우리는 이 단계를 변화 격리하기의 예로 볼 수 있다.
- 테스트 케이스에 인자를 추가하면 테스트 케이스에 영향을 주지 않으면서 자유로이 구현을 변경할 수 있다.
- 이제 단일값 대신 컬렉션을 사용할 수 있다.
```java
private int sum(int value, int[] valeus) {
    int sum= 0;
    for (int i= 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum;
}
```
- 다음에는 사용하지 않는 단일 인자를 삭제할 수 있다.
```java
public void teamSum() {
    assertEquals(5, sum(new int[] {5}));
}

private int sum(int[] values) {
    int sum = 0;
    for(int i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum;
}
```
- 직전 단계 역시 변화 격리하기의 예로, 코드를 고쳐서 테스트 케이스를 바꿔도 코드에 영향이 없도록 했다.
- 이제 우리는 계획대로 테스트 케이스를 개선할 수 있다.
```java
public void teadSum() {
    assertEquals(12, sum(new int[] {5, 7}));
}
```


## 29장 xUnit 패턴
- 다음은 xUnit 계열 테스팅 프레임워크를 위한 패턴이다.

### 단언(assertion)
> 테스트가 잘 작동하는지 어떻게 검사할 것인가?
- 불리언(boolean) 수식을 작성해서 여러분 대신 프로그램이 자동으로 코드가 동작하는지에 대한 판단을 수행하도록 하라
- 테스트를 완전히 자동화하려면 결과를 평가하는 데 개입되는 인간의 판단을 모조리 끄집어내야 한다.
> 컴퓨터가 실행하는 코드의 작동이 올바른지 검증하는 데 필요한 모든 판단이 되어야 한다는 것은 다음사항을 의미한다.
- 판단 결과가 불리언 값이어야 한다.
- 이 불리언 값은 컴퓨터에 의해 검증되어야 한다. 보통 다양한 형태의 assert() 메서드를 호출하여 이 값을 얻어낸다.

> assertTrue(rectangle.area() != 0) (X)
- 위와 같은 단언은 0이 아닌 아무 값이나 반환하게 만들어도 조건을 만족하므로 별로 유용하지 않다.
- 단언은 구체적이어야 한다.
- 만약 면적(area)가 50이어야 하면, 다음과 같이 면적이 50이어야 한다고 적어주어야 한다.
> assertTrue(rectangle.area() == 50) (O)
- 많은 xUnit 구현들이 동등성 검사를 위한 특별한 형태의 단언을 제공한다.
- 동등성 테스팅은 흔한데, 자신이 동등성을 테스팅한다는 것을 안다면 친절한 에러 메시지를 작성할 수 있다.
- JUnit : assertEquals(50, rectangle.area()

> 객체를 블랙박스처럼 취급하기란 쉽지 않다.
- 청약된(Offered) 혹은 시행중(Running)이라는 상태(Status)를 가질 수 있는 계약(Contract)에 대한 테스트를 작성하려고 한다.
```java
Contract contract= new Contract(); // 디폴트로 Offered status
contract.begin(); // Running으로 status 변경
assertEquals(Running.class, contract.status.class);
```
- 하지만 이 테스트는 status에 대한 현재 구현에 너무 의존적이다.
- status가 불리언 값으로 표현되도록 구현이 바뀌더라도 테스트가 통과할 수 있어야 한다.
- 아마도 status가 Running으로 바뀐다면 시행일이 언제인지 알아낼 수 있을 것이다.
```java
assertEquals(..., contract.startDate()); // status가 Offered라면 예외
```
- 내가 공용(public) 프로토콜만을 이용해서 모든 테스트를 작성해야 한다고 주장하는 것이 작금의 흐름에 거슬린다는 것을 안다.
- 변수의 값, 심지어 전용(private)으로 선언한 변수의 값까지도 테스트할 수 있도록 JUnit을 확장한 JXUnit이라는 패키지로 존재한다.
> 코드가 제대로 작동하는지를 판단하기 위한 용도로 변수를 사용하길 원한다면 언제나 설계를 향상할 수 있는 기회가 있다.
- 하지만 두려움 때문에 포기하고 그냥 변수를 사용하기로 결정해 버리면 이 기회를 잃게 된다.

> JUnit에서는 첫 번째 선택적 매개 변수(optional parameter)를 사용한다.
- assertTrue("참이어야 한다.", false)라고 작성한 후 실행하면
- "Assertion failed: 참이어야 한다."라는 에러 메시지를 보게 될 것이다.
- 어떤 팀에서는 모든 단언에 이 선택적 매개 변수를 사용하게 하는 규칙을 정해놓기도 한다.


### 픽스처
> 여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어떻게 하면 좋을까?
- 각 테스트 코드에 있는 지역 변수를 인스턴스 변수로 바꾸고 setUp() 메서드를 재정의하여 이 메서드에서 인스턴스 변수들을 초기화하도록 한다.

> 우리는 모델 코드에서 중복을 제거하길 원한다.
- 테스트 코드에서도 중복을 없애야 할까? 아마도 그럴 것이다.
- 문제는 이렇다.
- 객체들을 원하는 상태로 세팅하는 코드를 작성하고 나서,
- 이 객체들을 조작하고 결과를 테스트하는 코드를 만든다.
- 그런데 객체들을 세팅하는 코드는 여러 테스트에 걸쳐 동일한 경우가 있다.
- 이러한 객체들은 테스트 픽스처 혹은 발판이라 부른다.
- 이와 같은 중복은 다음과 같은 이유로 좋지 않다.
  - 복사해서 붙이기를 한다고 하더라도 이런 코드를 반복 작성하는 것엔 시간이 소요된다. 
  - 인터페이스를 수동으로 변경할 필요가 있을 경우, 여러 테스트를 고쳐주어야 한다. (이는 중복에 대해 정확히 예상되는 결과다.)
  
- 위에 말한 중복에 좋은 점도 존재한다.
- 객체 세팅 코드들이 단언이 적힌 메서드에 포함되면 우리는 테스트 코드를 그냥 위에서 아래로 읽어내려 갈 수 있다.
- 하지만, 객체 세팅 코드들이 별도의 메서드(setUp)로 분리되면 테스트의 나머지 부분을 작성하기 전에, 그 메서드가 자동으로 호출된다는 점과
객체들이 어떻게 초기화되었는지를 기억해야 한다.

> xUnit은 두 가지 스타일을 모두 지원한다.
- 쉽게 기억해 내지 못하는 사람들을 위해 픽스처를 생성하는 코드를 테스트 메서드에 포함시킬 수 있다.
- 공통의 픽스처 생성 코드를 setUp() 메서드로 옮겨 적을 수도 있다.

> 공통의 픽스처 생성 코드를 메서드로 분해하는 짧은 예시
```java
class EmptyRectangleTest {
    public void testEmpty() {
        Rectangle empty = new Rectagle(0,0,0,0);
        assertTrue(empty.isEmpty());
    }
    
    public void testWidth() {
        Rectangle empty = new Rectagle(0,0,0,0);
        assertEquals(0.0, empty.getWidth(), 0.0);
    }
}
```
- 다음과 같이 중복을 제거할 수 있다.
```java
class EmptyRectangleTest {
  private Rectangle empty;
  
  public void setUp() {
      empty = new Rectangle(0,0,0,0);
  }
  
  public void testEmpty() {
    assertTrue(empty.isEmpty());
  }

  public void testWidth() {
    assertEquals(0.0, empty.getWidth(), 0.0);
  }
}
```
- 공통 코드를 다른 메서드로 추출했다.
- 이 메서드들을 이해하려면 setUp()에 어떤 내용이 있는지 기억해야 한다.

> 어떤 스타일을 사용해야 할까?
- 두 가지 모두 시도해보기를 바란다.

> 새로운 종류의 픽스처는 각각 Test-Case의 새로운 하위 클래스여야 한다.
- 이 하위 클래스의 인스턴스 안에서 새로운 픽스처가 각각 생성되어 한 번 사용된 후 버려진다.
- 위 예제의 경우, 만약 비어 있지 않은 사각형에 대한 테스트를 작성하고자 했다면, NomalRectangleTest 정도의 이름으로 새로운 클래스를 만들었을 것이다.
- 이 클래스의 setUp()에서는 다른 사각형을 생성할 것이다.
- 만약 다른 픽스처가 필요할 때면, 난 보통 새로운 TestCase 하위 클래스를 만들어 낸다.
- 이 말은, 테스트 클래스와 모델 클래스 사이에 어떤 단순한 관계가 존재하지 않는다는 걸 의미한다.

### 외부 픽스처
> 픽스처 중 외부 자원이 있을 경우 이를 어떻게 해제(release)할 것인가?
- tearDown() 메서드를 재정의하여 이곳에서 자원을 해제하면 된다.
- 각 테스트의 목적 중 하나는 테스트가 실행되기 전과 실행된 후의 외부 세계가 동일하게 유지되도록 만드는 것임을 기억하기 바란다.
```python
testMethod(self):
    file= File("foobar").open()
    try:
        ...run the test...
    finally:
        file.close()
```
- 그런데 만약 파일이 여러 테스트에서 사용되었다면 이를 공통 픽스처의 일부로 만들 수 있을 것이다.
```python
setUp(self):
    self.file= File("foobar").open()
testMethod(self):
    try:
        ...run the test...
    finally:
        self.file.close()
```
- 하지만 일단 finally 절에 있는 귀찮은 중복은 우리가 설계에서 뭔가를 놓치고 있다는 점을 알려준다.
- 그 다음 이 메서드는 에러가 나기 쉬운데,
  - 우리가 finally 절을 잊거나 파일을 닫아야 한다는 사실 자체를 잊을 수도 있기 때문이다.
  - 마지막으로 테스트 안에 세줄의 잡음 (try, catch, finally)이 끼어 있는데, 이는 테스트를 실행하는 것과 큰 관련이 없다.
- xUnit은 각각의 테스트가 끝난 후에 tearDown()이 호출되는 것을 보장해준다.
```python
setUp(self):
    self.file= File("foobar").open()
testMethod(self):
    ...run the test...
tearDown(self):
    self.file.close()
```


### 테스트 메서드
> 테스트 케이스 하나를 어떻게 표현할 것인가?
- 'test'로 시작하는 이름의 메서드로 나타내면 된다.

> 객체지향 프로그래밍 언어는 세 가지 범주의 구조 계층을 제공한다.
- 모듈(자바의 패키지)
- 클래스
- 메서드

> 만약 테스트를 일반적인 소스코드처럼 작성하기 원한다면, 테스트를 위의 구조에 끼워 맞출 방법을 찾아야만 한다.
- 만약 픽스처를 표현하기 위해 클래스를 사용하기로 결정한다면 각각의 테스트를 위한 장소는 자연스럽게 메서드로 결정된다.
- 동일한 픽스처를 공유하는 모든 테스트는 동일한 클래스의 메서드로 작성될 것이다.
- 다른 종류의 픽스처를 필요로 하는 테스트는 다른 클래스에 존재하게 된다.

> 관습에 의해 메서드 이름은 'test'로 시작한다.
- 툴은 이 패턴을 자동으로 인식하고 주어진 클래스에 대한 테스트 슈트를 생성한다.
- 메서드 이름의 나머지 부분은 나중에 아무것도 모르는 사람이 이 코드를 읽더라도 왜 이 테스트가 작성되었는지 알 수 있도록 단서를 주어야 한다.

> 테스트 메서드는 의미가 그대로 드러나는 코드로, 읽기 쉬워야 한다.
- 테스트 코드가 점점 길어지고 복잡해진다면, 아기걸음 게임을 할 필요가 있다.
- 아기걸음 게임의 목적은 최종 목표에 좀더 다가갈 수 있게 해주는 가장 짧은 테스트를 작성하는 것이다.
- 일부러 코드를 꼬는 일이 없다면 대략 세 줄이 최소가 될 것이다.
- '아웃라인'을 작성하는 것도 방법이다.

### 예외 테스트
> 예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성할 것인가?
- 예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 한해서 테스트가 실패하게 만들면 된다.
- 어떤 값을 찾는 테스트를 작성한다고 치자. 값이 찾아지지 않으면 예외가 던져지길 원한다.
- 일단 값을 찾는 테스트는 간단하다.
```java
public void testRate() {
    exchange.addRate("USD", "GBP", 2);
    int rate= exchange.findRate("USD", "GBP");
    assertEquals(2, rate);
}
```
- 하지만 예외가 제대로 발생하는지에 대해 테스트할 방법이 쉽게 떠오르지 않는다.
- 다음과 같이 하면 된다.
```java
public void testMissingRate() {
    try {
        exchange.findRate("USD", "GBP");
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
```
- findRate()가 예외를 던지지 않는다면 fail()이 호출될 것이다.
- fail()은 테스트가 실패했음을 알려주는 xUnit 메서드다.
- 우리가 원하는 정확한 종류의 예외만을 잡아내야 한다는 점에 유의하기 바란다.
- 그래야만 우리가 원하는 예외가 아닌, 다른 예외가 발생할 경우 테스트가 적절히 실패할 것이기 때문이다.

### 전체 테스트
> 모든 테스트를 한번에 실행하려면 어떻게 해야 할까?
- 모든 테스트 슈트에 대한 모음을 작성하면 된다. (각각의 패키지에 대해 하나씩, 그리고 전체 애플리케이션의 패키지 테스트를 모아주는 테스트 슈트).
- TestCase의 하위 클래스 하나를 패키지에 추가하고 나서 그 클래스에 테스트 메서드를 하나 추가한다고 가정.
- 다음에 테스트를 전부 돌릴 때 그 테스트 메서드도 실행되어야 한다.
- 각각의 패키지는 AllTests라는 이름의 클래스를 가지고 있어야 한다.
- 이 클래스는 TestSuite 인스턴스를 반환하는 sutie()라는 이름의 정적 메서드를 가지고 있어야 한다.
```java
public class AllTests {
    public static void main(String[] args) {
        junit.swingui.TestRunner.run(AllTests.class);
    }
    
    public static Test suite() {
        TestSuite result = new TestSuite("TFD tests");
        result.addTestSuite(MoneyTest.class);
        result.addTestSuite(ExchangeTest.class);
        result.addTestSuite(IdentityRateTest.class);
        return result;
    }
}
```
- AllTests에 main() 메서드를 구현하여 IDE 혹은 명령줄에서 직접 실행되게 할 수도 있다.

## 30장 디자인패턴
- 우리가 언제나 완전히 다른 문제들을 해결하는 것 같지만 우리가 푸는 문제 대다수는 
- 사용하는 도구에 의해 생기는 것이지 직면한 외부의 문제 때문에 생기는 것이 아니다.
- 이런 이유로, 심지어 외부적 문제 해결 컨텍스트가 엄청나게 다양하더라도 공통의 해결책을 가진 공통의 문제를 발견할 것을 기대할 수 있다.

> 객체를 적용해서 계산을 조직화하는 것
- 객체를 적용해서 계산을 조직화하는 것은 내부 생성된 공통적이고 부차적인 문제들을 역시 공통적이고 예측 가능한 방법들로 해결하는 가장 좋은 예 중 하나가 된다.
- TDD에서는 설계를 디자인 패턴과는 조금 다른 관점으로 본다.

> TDD 관점에서 보는 디자인 패턴
- 커맨드 - 계산 작업에 대한 호출을 메시지가 아닌 객체로 표현한다.
- 값 객체 - 객체가 생성된 이후 그 값이 절대로 변하지 않게 하여 별칭 문제가 발생하지 않게 한다.
- 널 객체 - 계산 작업의 기본 사례를 객체로 표현한다.
- 템플릿 메서드 - 계산 작업의 변하지 않는 순서를 여러 추상 메서드로 표현한다. 이 추상 메서드들은 상속을 통해 특별한 작업을 수행하게끔 구체화된다.
- 플러거블 객체 - 둘 이상의 구현을 객체를 호출함으로써 다양성을 표현한다.
- 팩토리 메서드 - 생성자 대신 메서드를 호출함으로써 객체를 생성한다.
- 임포스터 - 현존하는 프로토콜을 갖는 다른 구현을 추가하여 시스템에 변이를 도입한다.
- 컴포지트 - 하나의 객체로 여러 객체의 행위 조합을 표현한다.
- 수집 매개 변수 - 여러 다른 객체에서 계산한 결과를 모으기 위해 매개 변수를 여러 곳으로 전달한다.


### 커맨드
> 간단한 메서드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요한다면 어떻게 해야 할까?
- 계산 작업에 대한 객체를 생성하여 이를 호출하면 된다.

> 메세지 보내기
- 메시지 보내기는 참 훌륭한 기능이다. 프로그래밍 언어는 문법적으로 쉽게 메시지를 보낼 수 있게 해주며, 프로그래밍 환경은 메시지를 쉽게 다룰 수 있도록 도와준다.
- 하지만 가끔은 단순히 메시지를 보내는 것만으로는 충분하지 않을 때가 있다.
- 예를 들어 메시지를 보냈다는 사실을 로그로 남기길 원한다고 생각해보자.
- 물론 언어에 새로운 특성(wrapper method)을 추가하는 방법도 있겠지만,
- 그러기엔 로깅 기능이 쓰이는 빈도가 매우 낮고, 이에 비해서 간결한 언어가 우리에게 주는 가치는 너무도 높다.
- 언어에 새로운 특성을 추가하지 않는게 좋을 것이다.
- 또 다른 예는 어떤 계산을 수행하고 싶긴 한데 나중에 하고 싶을 때
- 이 경우에 새로운 스레드를 생성하고 멈춘 후에 나중에 원하는 시점에서 다시 시작할 수 있겠지만
- 이렇게 한다면 우린 온갖 동시성 문제를 고민해야 할 것이다.

> 복잡한 계산 작업 호출은 값비싼 메커니즘을 필요로 한다.
- 하지만 거의 대부분의 경우 이런 복잡함이 요구되지는 않는다.
- 메시지 하나를 보내는 것보다 호출이 조금 더 구체적이고 조작하기 쉬워지려면, 바로 객체가 해답이 된다.

> 호출 자체를 나타내기 위한 객체를 만드는 것이다. 
- 객체를 생성할 때 계산에 필요한 모든 매개 변수들을 초기화한다.
- 호출할 준비가 되면 run()과 같은 프로토콜을 이용해서 계산을 호출한다.
- 자바의 Runnable 인터페이스
```java
class Runnable {
    public abstract void run();
}
```
- run()의 구현으로는 여러분이 원하는 어떤 것을 넣어도 된다.
- 불행히도 자바는 Runnable을 생성하고 호출하기 위한, 문법적으로 간결한 방법을 제공하지 않기 때문에
- 이 인터페이스가 스몰토크/루비 혹은 리스프의 블럭 혹은 람다 처럼 자주 쓰이지는 않는다.

### 값 객체
> 널리 공유해야 하지만 동일성은 중요하지 않을 때 객체를 어떤식으로 설계할 수 있을까?
- 객체가 생성될 때 객체의 상태를 설정한 후 이 상태가 절대 변할 수 없도록 한다.
- 그리고 이 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하게 만든다.

> 객체는 정말 멋진 것이지만, 작은 문제가 하나 있다.
- '나'라는 어떤 객체가 있는데, '내'가 Rectangle 객체를 갖는다고 가정 해보자.
- 나는 Rectangle에 기반을 두고 이를테면 면적 같은 어떤 값을 계산한다.
- 나중에 누군가가 내가 가진 Rectangle 객체를 빌려 달라고 요청하고,
- 나는 Rectangle을 그에게 빌려준다.
- 잠시 후 내가 모르는 사이에 내 Rectangle 객체의 상태가 변하게 된다.
- 따라서 내가 좀 전에 계산한 면적이 더는 쓸모가 없게 되지만, 내가 그 사실을 알 방법은 전혀 없다.
- 이게 고전적인 별칭 문제이다.

> 별칭 문제를 해결하기 위한 몇가지 방법
- 현재 의존하는 객체에 대한 참조를 결코 외부로 알리지 않는 방법. 그 대신 객체에 대한 복사본을 제공한다.
  - 시간이나 공간 측면에서 비싼 해결책일 수도 있다.
  - 공유 객체의 상태 변화를 공유하고 싶은 경우엔 사용불가하다.
- 옵저버 패턴을 사용하는 방법. 의존하는 객체에 자기를 등록해 놓고 객체의 상태가 변하면 통지를 받는 방법이다.
  - 제어 흐름을 이해하기 어렵게 만들 수 있다.
  - 의존성을 설정하고 제거하기 위한 로직이 지저분해질 수 있다.
- 객체를 덜 객체답게 취급하는 방법. 객체는 시간의 흐름에 따라 변할 수 있는 상태를 갖고 있다. 우리가 원한다면 이 상태를 제거해버릴 수 있다.
  - 이 객체가 변하지 않을 것임을 안다면 이 객체에 대한 참조를 원하는 곳 어디로든 넘겨줄 수 있다.
  
> 값 객체를 구현할 때 모든 오퍼레이션은 기존 객체는 변하지 않은 채로 놔두고, 새로운 객체를 반환해야 한다.
- 이런 객체 할당은 퍼포먼스 문제를 야기할 수 있다.
- 이런 문제는 모든 퍼포먼스 문제와 동일하게 실질적인 자료 집합이 있고, 실질적 사용패턴, 프로파일링 데이터,
퍼포먼스에 대한 불만 등이 실재로 존재하는 상황 하에서만 고민해야 한다.
  
> 모든 값 객체는 동등성을 구현해야 한다.
- 만약 내가 계약 객체를 두 개 가지고 있는데 둘이 서로 같은 객체가 아니라면 이 둘은 동등한 것이 아니라 다른 것이다.
- 하지만 내게 5프랑짜리 동전이 두 개 있다면 이것들이 동일한 동전인지는 중요하지 않다.
- 5프랑은 5프랑인 거다. 이것들은 서로 동등해야 한다.


### 널 객체
> 객체의 특별한 상황을 표현하고자 할 때 어떻게 해야 할까?
- 그 특별한 상황을 표현하는 새로운 객체를 만들면 된다.
- 그리고 이 객체에 다른 정상적인 상황을 나타내는 객체와 동일한 프로토콜을 제공한다.
```java
// java.io.File에서 영감을 얻음
public boolean setReadOnly() {
    SecurityManager guard = System.getSecurityManager();
    if (guard != null) {
        guard.canWrite(path);    
    }
    return fileSystem.setReadOnly(this);
}
```
- java.io.File에는 guard != null이 18번이나 나온다.
- 비록 이러한 근면함 덕택에 세상의 파일들이 안전하게 지켜진다는 점을 인정하긴 하지만
- 한편으로는 조금 신경질도 난다.
- getSecurityManager()가 null을 반환하는지 항상 조심스럽게 검사해야만 하는 걸까?

> 다른 방법은 절대로 예외를 던지지 않는 새로운 클래스(LaxSecurity)를 만드는 것이다.
```java
class LaxSecurity {
    public void canWrite(String path) {
    }
}
```
- 누군가가 SecurityManager를 요청했는데, 반환할 SecurityManager가 없다면 그 대신 LaxSecurity를 반환하면 된다.
```java
class SecurityManager {
    public static SecurityManager getSecurityManager() {
        return security == null ? new LaxSecurity() : security;
    }
}
```
- 이제 더는 누군가 널 검사를 하지 않았을까 하는 걱정은 하지 않아도 된다.
- 원래의 코드는 다음과 같이 무척 깔끔해진다.
```java
public boolean setReadOnly() {
    SecurityManager security = System.getSecurityManager();
    security.canWrite(path);
    return fileSystem.setReadOnly(this);
}
```

### 템플릿 메서드
> 작업 순서는 변하지 않지만 각 작업 단위에 대한 미래의 개선 가능성을 열어두고 싶은 경우 이를 어떻게 표현할 것인가?
- 다른 메서드들을 호출하는 내용으로만 이루어진 메서드를 만든다.

> 프로그래밍이랑 고전적인 순서들로 가득하다.
- 입력/처리/출력
- 메시지 보내기/응답 받기
- 명령 읽기/결과 보내기

> 이러한 순서들의 범용성에 대해서 명백하게 나타내는 동시에 각 단계의 구현에 대해서는 변화를 주고 싶은 경우가 있다.
- 객체지향 언어는 상속을 통해 범용적인 순서를 표현하기 위한 간단한 방법을 제공한다.
- 상위 클래스에는 다른 메서드를 호출하는 내용으로만 이루어진 메서드를 만들고
- 하위 클래스에서는 이 각각의 메서드를 서로 다른 방식으로 구현한다.
```java
class TestCase {
    public void runBare() throws Throwable {
        setUp();
        try {
            runTest();
        }
        finally {
            tearDown();
        }
    }
}
```
- 하위 클래스는 그들이 원하는 대로 setUp(), runTest(), tearDown()을 구현하면 된다.
- 템플릿 메서드를 만들 때 한가지 문제는 하위 클래스를 위한 기본 구현을 제공할 것인가 말 것인가 하는 것이다.
- TestCase.runBare()에서는 세 개의 메서드가 모두 기본 구현을 가지고 있다.
  - setUp()과 tearDown()은 아무 일도 하지 않는다.
  - runTest()는 테스트 메서드를 이름에 기반하여 동적으로 찾아서 호출한다.
- 하위 단계가 정의되지 않은 상태에서 연산을 구현하는 것이 의미가 없는 경우라면,
- 여러분이 사용하는 언어가 제공하는 어떠한 방법을 이용하건 간에 이를 나타내야 한다.
  - 자바에서는 하위 메서드를 추상 메서드로 선언한다.
  - 스몰토크에서는 메서드가 SubclassResponsibility 에러를 던지게 만든다.
- 템플릿 메서드는 초기의 설계에 의해서 얻어지는 것보다는 경험에 의해 발견되는 것이 좋다.
- "아, 이 부분은 순서에 관한 내용이고, 이 부분이 상세한 구현에 대한 내용이로군."
- 하는 생각이 들 때면 늘 그 상세한 구현을 나중에 인라인시키고 진짜로 변하는 부분만 다시 추출한다.

> 두 하위 클래스에서 어떤 연산 순서의 두 가지 변주를 발견하면
- 양자가 점차 가까워지도록 둘을 같이 움직여가야 한다.
- 나머지 메서드들과는 다른 부분을 추출해 내면 남는 것은 템플릿 메서드다.
- 그 다음 템플릿 메서드를 상위 클래스로 보내고 중복을 제거할 수 있다.


### 플러거블 객체
> 변이를 어떻게 표현할 것인가?
- 명시적인 조건문을 사용한다.
```java
if(circle) then {
. . . circley stuff. . .
} else {
. . . non circley stuff    
}
```
- 하지만 이러한 명시적 조건문은 여러 곳으로 퍼져나간다는 사실을 알게 될 것이다.
- 원과 원이 아닌 것을 구분하기 위해 한 곳에서 명시적 조건문을 사용하면
- 조건문은 조만간 퍼져 나갈 것이다. (중복이 생겨간다는 의미)

> TDD의 두 번째 수칙 : 중복을 제거하기
- 명시적인 조건문이 전염되는 싹을 애초에 잘라버려야 한다.
- 조건문을 두 번째로 볼 때가 바로, 객체 설계시의 가장 기초인 플러거블 객체를 끄집어낼 때다.
- 단순히 중복을 제거하기 위해 얻은 플러거블 객체는 종종 반직관적이다.

> 그래픽 편집기를 작성할 때 선택의 예시
- 그래픽 편집기를 작성할 때 선택(selec-tion)은 사실 좀 복잡하다.
- 마우스 버튼을 누를 때,
  - 어떤 도형 위에 있는 경우
    - 마우스를 움직이면 : 해당 도형을 이동
    - 마우스를 놓으면 : 해당 도형이 선택
  - 어떤 도형 위에 있지 않는 경우
    - 마우스를 누르면 : 도형 집합을 선택
    - 마우스를 움직이면 : 일반적으로 여러 도형을 선택하는 데 사용된 사각형의 크기를 바꿈
    - 마우스를 놓으면 : 사각형 안의 도형이 선택
- 초기 코드
```java
class SelectionTool {
    Figure selected;
    public void mouseDown() {
        selected= findFigure();
        if (selected != null)
            select(selected);
    }
    public void mouseMove() {
        if (selected != null)
            move(selected);
        else
            moveSelectionRectangle();
    }
    public void mouseUp() {
        if (selected == null)
            selectAll();
    }
}
```
- 이게 바로 지저분한 중복 조건문들이다. (이것들은 질병처럼 번져나간다.)
- 이 경우에 대한 해법은 플러거블 객체인 SelectionMode를 만드는 것이다.
- SelectionMode는 SingleSelection과 MultipleSelection이라는 두 가지 구현을 갖는다.
```java
class SelectionTool {
    SelectionMode mode;
    public void mouseDown() {
        selected= findFigure();
        if (selected != null)
            mode= SingleSelection(selected);
        else
            mode= MultipleSelection();
    }
    public void mouseMove() {
        mode.mouseMove();
    }
    public void mouseUp() {
        mode.mouseUp();
    }
}
```
- 명시적인 인터페이스를 사용하는 언어에서는 두 플러거블(혹은 그 이상의) 객체가 동일한 인터페이스를 구현하게 해야 한다.


### 플러거블 셀렉터
> 인스턴스별로 서로 다른 메서드가 동적으로 호출되게 하려면 어떻게 해야 할까?
- 메서드의 이름을 저장하고 있다가 그 이름에 해당하는 메서드를 동적으로 호출한다.
- 각각 단지 메서드 하나만 구현하는 하위 클래스가 열 개 있다면 어떻게 해야 할까?
- 상속은 이런 작은 변이를 다루기에는 너무 무거운 기법이다.

```java
abstract class Report {
  abstract void print();
}

class HTMLReport extends Report {
  void print() {...
  }
}
class XMLReport extends Report {
  void print() {...
  }
}
```
- 한 가지 대안은 switch 문을 갖는 하나의 클래스를 만드는 것이다.
- 필드의 값에 따라 서로 다른 메서드를 호출하면 된다.
- 하지만 메서드의 이름이 세 곳에 나뉘어 존재하게 된다.
  - 인스턴스 생성하는 곳
  - switch문
  - 메서드 자체

```java
abstract class Report {
    String printMessage;
    Report (String printMessage) {
        this.printMessage= printMessage;
    }
    void print() {
        switch (printMessage) {
          case "printHTML" :
              printHTML();
              break;
          case "printXML" :
            printXML();
            break;
        }
    }
    
    void printHTML() {
    }
    
    void printXML() {
    }
}
```  
- 새로운 종류의 출력을 추가할 때마다 출력 메서드를 추가하고 switch 문을 바꿔야 한다는 점을 기억해야 한다.
- 플러거블 셀럭터 해법은 리플랙션을 이용하여 동적으로 메서드를 호출하는 것이다.
```java
void print() {
    Method runMethod= getClass().getMethod(printMessage, null);
    runMethod.invoke(this, new Class[0]);
}
```
- 여전히 리포트를 생성하는 곳과 출력 메서드의 이름 사이에 지저분한 의존 관계가 남아 있긴 하지만 최소한 switch 문은 없다.
- 플러거블 셀렉터는 분명 과용될 수 있다.
- 가장 큰 문제는 메서드가 호출되었는지 보기 위해 코드를 추적하는 것이다.
- 메서드를 달랑 한 개만 가지고 있는 하위 클래스들이 한 뭉치나 존재하는,
- 확실히 직관적인 상황에서 코드를 정리하기 위한 용도로만 플러거블 셀럭터를 사용해야 한다.


### 팩토리 메서드
> 새 객체를 만들 때 유연성을 원하는 경우 어떻게 생성하는가?
- 생성자를 쓰는 대신 일반 메서드에서 객체를 생성한다.
- 생성자는 자신을 잘 표현한다.
- 생성자를 사용하는 경우 분명히 객체 하나를 생성하고 있다는 것을 알 수 있다.
- 그러나 생성자는, 특히 자바에서 표현력과 유연함이 떨어진다.
- 우리가 통화 예제에서 필요로 한 유연함의 한 측면은 생성자에서 다른 클래스의 객체를 생성할 수 있게 하는 것이었다.
```java
public void testMultiplication() {
    Dollar five= new Dollar(5);
    assertEquals(new Dollar(10), five.times(2));
    assertEquals(new Dollar(15), five.times(3));
}
```
- 우리는 Money 클래스를 도입하고 싶었지만, Dollar 객체를 생성하는 데 발이 묶여 있는 한 그렇게 할 수 없었다.
- 메서드라는 한 단계의 인디렉션을 추가함으로써 테스트를 변경하지 않고 다른 클래스의 인스턴스를 반환할 수 있는 유연함을 얻었다.
```java
public void testMultiplication() {
    Dollar five = Money.dollar(5);
    assertEquals(new Dollar(10), five.times(2));
    assertEquals(new Dollar(15), five.times(3));
}

class Money {
    static Dollar dollar(int amount) {
        return new Dollar(amount);
    }
}
```
- 이 메서드를 팩토리 메서드라 부른다.
- 객체를 생성하기 때문이다.
- 팩토리 메서드의 단점은 인디렉션에 있다.
- 메서드가 생성자처럼 생기지는 않았지만 그 안에서 객체를 만든다는 사실을 기억해야만 한다.
- 유연함이 필요할 때에만 팩토리 메서드를 사용해야 한다.
- 그렇지 않다면 객체를 생성하는 데에는 생성자를 쓰는 것으로 충분하다.


### 사칭 사기꾼
> 기존의 코드에 새로운 변이를 도입하려면 어떻게 해야 할까?
- 기존의 객체와 같은 프로토콜을 갖지만 구현은 다른 새로운 객체를 추가한다.
- 절차적 프로그램에서는 변이를 도입하려면 조건문을 추가해야 했다.
- 플러거블 객체에서 살펴본 바와 같이 그런 로직은 증식하려는 경향(중복)이 있고,
- 이 중복을 치료하려면 다형성 메시지 처방을 1회분 복용해야 한다.

> 구조가 이미 존재한다고 가정
- 객체도 이미 존재.
- 이제 시스템이 뭔가 다른 일을 처리하도록 만들고 싶어졌다.
- if 문을 삽입할 명백한 장소가 있고, 다른 곳에 중복된 로직을 넣지 않을 수 있다면 그렇게 하면 된다.
- 그러나, 이러한 변이를 도입할 때 여러 메서드를 수정해야 하는 경우가 종종 있다.

> 이러한 결정의 순간은 TDD에서 두 군데 나타난다.
- 때때로 테스트 케이스 하나를 작성하는 데 새로운 시나리오를 표현해야 한다.
- 기존 객체 중 어느 것도 당신이 표현하고 싶어하는 것을 표현하지 못한다.
- 우리가 그래픽 데이터를 테스트하고 있고, 이미 사각형(retangle)을 제대로 그린다고 가정하자.
```java
testRectangle() {
    Drawing d= new Drawing();
    d.addFigure(new RectangleFigure(0, 10, 50, 100));
    RecordingMedium brush= new RecordingMedium();
    d.disply(brush);
    assertEquals("rectangle 0 10 50 100\n", brush.log());
}
```
- 이제 타원을 표시하고 싶다. 이 경우, 사칭 사기꾼(imposter)을 발견하기는 쉽다.
- RectangleFigure를 OvalFigure로 바꾸면 된다.
```java
testOval() {
    Drawing d= new Drawing();
    d.addFigure(new OvalFigure(0, 10, 50, 100));
    RecordingMedium brush= new RecordingMedium();
    d.disply(brush);
    assertEquals("oval 0 10 50 100\n", brush.log());
}
```
- 일반적으로 사칭 사기꾼을 사용할 곳을 한번에 집어내는 데에는 통찰력이 필요하다.
- Money들의 벡터가 Money 하나인 것처럼 행동할 수 있다는 워드 커닝엄의 통찰이 꼭 그러한 예다.
- 서로 다르다고 생각한 것을 이제는 똑같이 볼 수 있다.
- 다음은 리팩토링 중에 나타나는 사칭 사기꾼의 두 가지 예다
  - 널 객체 : 데이터가 없는 상태를 데이터가 있는 상태와 동일하게 취급할 수 있다.
  - 컴포지트 : 객체의 집합을 단일 객체처럼 취급할 수 있다.
- 리팩토링 중에 사칭 사기꾼을 찾아내는 것은 중복을 제거하는 작업을 통해 유도된다.
- 다른 모든 리팩토링 역시 중복을 제거하는 작업에 의해 유도된다.


### 컴포지트
> 하나의 객체가 다른 객체 목록의 행위를 조합한 것처럼 행동하게 만들려면 어떻게 해야 할까?
- 객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현한다.

> Account와 Transaction의 예
- 컴포지트의 반대에 대한 예
- Transaction은 값의 증분을 저장한다.

```java
class Transaction {
    Transaction(Money value) {
        this.value= value;
    }
}
```
- Account는 Transaction들의 합을 계산함으로써 잔액을 얻어낸다.
```java
class Account {
    Transaction transactions[];
    Money balance() {
        Money sum= Money.zero();
        for (int i= 0; i < transactions.length; i++) {
            sum= sum.plus(transactions[i].value);
        }
        return sum;
    }
}
```
- 이는 충분히 단순해 보인다.
  - Transaction은 값을 갖는다.
  - Account는 잔액을 갖는다.
- 이제부터 흥미로운 부분이다.
- 고객은 여러 계좌를 가지고 있고 전체 계좌의 잔액을 알고 싶어한다.
- 이를 구현하는 명백한 방법 한 가지는 새로운 클래스인 OverallAccount를 만드는 것이다.
- OverallAccount는 모든 Account의 잔액을 합친다. 중복! 중복!

> Account와 Balance가 동일한 인터페이스를 갖게 만들면 어떨까?
- 일단 아직까지는 더 좋은 이름이 떠오르지 않으므로 이름을 Holding(소유 재산)이라고 해두자.
```java
interface Holding
    Money balance();
```
- Transaction에서는 balance()가 value를 반환하게 만들면 된다.
```java
class Transaction {
    Money balance() {
        return value;
    }
}
```
- 이제 Account는 Transaction이 아닌 Holding의 조합(composite)으로 만들 수 있다.
```java
class Account {
    Holding holdings[];
    Money balance() {
        Money sum= Money.zero();
        for (int i= 0; i < holdings.length; i++) {
            sum= sum.plus(holdings[i].balance());
        }
        return sum;
    }
}
```
- 이제 OverallAccount에 대한 문제는 사라졌다.
- OverallAccount는 단지 Account를 담고 있는 Account일 뿐이다.
- 위를 보면 컴포지트의 냄새가 드러나 있다.
- 실세계에서는 거래(transac-tion)에 잔액(balance)이 존재하지 않는다.
- 컴포지트 패턴을 적용하는 것은 프로그래머의 트릭이지 세상 사람들에게 일반적으로 받아들여지는 것은 아니다.
- 그렇지만 프로그램 설계에서 얻는 이득은 엄청난 것이어서, 이러한 개념적 단절은 종종 그만한 가치가 있다.
- Folder는 Folder를 포함하고, TestSuite는 TestSuite를 포함하며,
- Drawing은 Drawing을 포함한다고 할 때 이런 것들이 모두 실세계와 잘 들어맞지는 않지만 전부 코드를 훨씬 더 단순하게 만든다.

- 이 논의에서 알 수 있는 바와 같이 난 아직도 어떤 경우에 객체의 컬렉션이 단순히 객체의 컬렉션이어야 하고,
- 어떤 경우에 컴포지트여야 하는지 잘 모르겠다.
- 한 가지 좋은 소식은 여러분이 리팩토링에 점차 익숙해지고 있으므로,
- 중복이 나타나는 그 순간에 컴포지트를 도입해보고 이로 인해 프로그램의 복잡함이 사라지는지 관찰해볼 수 있다는 점이다.


### 수집 매개 변수
> 여러 객체에 걸쳐 존재하는 오퍼레이션의 결과를 수집하려면 어떻게 해야 할까?
- 결과가 수집될 객체를 각 오퍼레이션의 매개 변수로 추가한다.

> java.io.Externalizable 인터페이스
- writeExternal 메서드는 객체와 그 객체가 참조하는 모든 객체를 기록한다.
- 모든 객체가 기록되기 위해서는 이것들이 모두 느슨하게 협력해야 하므로
- 메서드는 수집 매개 변수로서 ObjectOutput을 전달한다.
```java
// java.io.Externalizable
public void interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
}
```
- 수집 매개 변수를 추가하는 것은 컴포지트의 일반적인 귀결이다.
- JUnit을 개발할 때, 테스트가 여러 개 되기 전까지는 여러 테스트의 결과를 대조하기 위해 TestResult가 필요하지 않았다.
- 기대하는 결과가 더 복잡해지면, 수집 매개 변수를 도입할 필요를 느낄 수도 있다.

> Expression을 출력한다고 가정해보자
- 우리가 원하는 게 평범한 문자열이라면 단순한 문자열 결합으로 충분하다.
```java
testSumprinting() {
    Sum sum= new Sum(Money.dollar(5), Money.franc(7));
    assertEquals("5 USD + 7 CHF", sum.toString());
}

String toString() {
    return augend + " + " + addend;
}
```
- 하지만 수식을 트리 형태로 들여쓰기하길 원한다면 코드는 다음과 같아질 것이다.
```java
testSumPrinting() {
    Sum sum= new Sum(Money.dollar(5), Money.franc(7));
    assertEquals("+\n\t5 USD\n\t7 CHF", sum.toString());
}
```
- 우린 다음과 같은 수집 매개 변수를 도입해야 할 것이다.
```java
String toString() {
    IndentingStream writer= new IndentingStream();
    toString(writer);
    return writer.contents();
}

void toString(IndentingWriter writer) {
    writer.println("+");
    writer.indent();
    augend.toString(writer);
    writer.println();
    addend.toString(writer);
    writer.exdent();
}
```


### 싱글톤
> 전역 변수를 제공하지 않는 언어에서 전역 변수를 사용하려면 어떻게 해야 할까?
- 사용하지 마라.



## 31장 리팩토링
- 이 패턴들은 시스템의 설계를 작은 단계를 통해 변화 시키는 방법에 대해 설명한다.
- 리팩토링은 어떤 상황에서도 프로그램의 의미론을 변경해서는 안 된다.
- 하지만 TDD에서는 상수를 변수로 바꾸고 양심에 거리낌 없이 이를 리팩토링이라고 부른다.
  - 이 행위가 통과하는 테스트의 집합에 아무 변화도 주지 않기 때문이다.
- 이 '관측상의 동치성'이 성립되려면 충분한 테스트를 가지고 있어야 한다.
  - 충분한 테스트란, 현재 가지고 있는 테스트들에 기반한 리팩토링이 
    추측 가능한 모든 테스트에 기반한 리팩토링과 
    동일한 것으로 여겨질 수 있는 상태

### 차이점 일치시키기
> 비슷해 보이는 두 코드 조각을 합치려면 어떻게 해야 할까?
- 두 코드가 단계적으로 닮아가게끔 수정한다.
- 이 둘이 완전히 동일해지면 둘을 합친다.
- 만약 내가 메서드를 기계적으로 정확히 추출해냈다면 시스템의 행위에 변화가 생길 가능성은 매우 희박하다.
- 하지만 어떤 리팩토링의 경우에는 제어 흐름과 같은 데이터 값을 세밀하게 검사해야 할 필요가 있기도 하다.

> 불확실한 믿음에 의지하여 단계를 크게 건너뛰는 리팩토링을 피해가자
- 작은 단계와 명확한 피드백을 이용해서
- 물론, 이런 크게 도약하는 리팩토링을 완전히 피할 수는 없겠지만, 발생 빈도를 줄일 수는 있다.
- 이 리팩토링은 모든 규모의 작업에서 발생한다.
  - 두 반복문의 구조가 비슷하다 : 이 둘을 동일하게 만들고 나서 하나로 합친다.
  - 조건문에 의해 나눠지는 두 분기의 코드가 비슷하다 : 이 둘을 동일하게 만들고 나서 조건문을 제거한다.
  - 두 클래스가 비슷하다 : 이 둘을 동일하게 만들고 나서 하나를 제거한다.

> 간혹 차이점 일치시키기를 거꾸로 수행해야 하는 경우도 있다.
- 변경 마지막 단계에 사소한 것만 처리하게 하려면 어떤 모양새가 되어야 할까 생각한 다음 거꾸로 거슬러 온다는 것.
- 예를 들어 여러 개의 하위 클래스를 제거하길 원할 때
  - 하위 클래스의 내용이 비어 있다면 마지막 작업은 간단하다.
  - 단지 하위 클래스에 대한 참조를 상위 클래스로 바꿔주기만 하면 된다.
  - 이 작업은 시스템의 행위를 변경하지 않는다.
  - 하위 클래스의 내용이 비어 있으려면 메서드의 내용이 상위 클래스의 메서드 내용과 동일하면 된다.
  - 하나씩 하나씩 하위 클래스의 내용을 비우고, 모두 비게 되면 하위 클래스에 대한 참조를 상위 클래스로 바꾼다.
  

### 변화 격리하기
> 객체나 메서드의 일부만 바꾸려면 어떻게 해야 할까?
- 일단 바꿔야 할 부분을 격리한다.
  - 수술 장면의 예시 
  - 수술 부위만 빼고 환자의 몸은 천으로 덮여있다.
  - 천으로 가리는 것은 어떤 고정된 변수 몇 가지만을 외과의사에게 노출시키는 것과 같다.
- 일단 바꿀 부분을 격리하고 나서 바꾸는 작업을 수행하면 작업을 되돌리기도 매우 수월하다.
- findRate()에서 인스턴스 변수를 반환하는 것이 우리가 해야 할 일의 전부라고 알게 되었다면,
  - findRate()가 사용되는 모든 곳에서 그걸 인라인시키고 삭제해 버리는 것을 고려해야 한다.
  - 하지만 이걸 생각 없이 자동으로 변경하지는 마라
  - 코드에 메서드가 하나 더 명시되는 비용과 또 하나의 개념이 명시되는 가치, 이 양자 간의 균형을 잡도록 하자

> 변화를 격리하기 위해 사용할 수 있는 몇가지 방법
- 메서드 추출하기 (가장 일반적)
- 객체 추출하기
- 메서드 객체


### 데이터 이주시키기
> 표현 양식을 변경하려면 어떻게 해야 할까?
- 일시적으로 데이터를 중복시킨다.

#### 방법
- 내부에서 외부로 변화시키는 방법
- 내부에서 외부로의 변화란? 내부의 표현 양식을 변경한 후 외부 인터페이스를 변화시키는 방법
  - 새로운 포맷의 인스턴스 변수를 추가한다.
  - 기존 포맷의 인스턴스 변수를 세팅하는 모든 부분에서 새로운 인스턴스 변수도 세팅하게 만든다.
  - 기존 변수를 사용하는 모든 곳에서 새 변수를 사용하게 만든다.
  - 기존 포맷을 제거한다.
  - 새 포맷에 맞게 외부 인터페이스를 변경한다.

- API를 먼저 변화시키기를 원할 때
  - 새 포맷으로 인자를 하나 추가한다.
  - 새 포맷 인자에서 이전 포맷의 내부적 표현양식으로 변역한다.
  - 이전 포맷 인자를 삭제한다.
  - 이전 포맷을 사용하는 것들을 새 포맷으로 바꾼다.
  - 이전 포맷을 지운다.
  
#### 이유
- '하나에서 여럿으로'는 한상 데이터 이주시키기 문제를 만들어낸다.
- TestSuite에 '하나에서 여럿으로'를 적용하려고 하는 상황 가정
```python
def testSuite(self):
    suite= TestSuite()
    suite.add(WasRun("testMethod"))
    suite.run(self.result)
    assert("1 run, 0 failed" == self.result.summary())
```
- 이는 아래와 같이 구현될 수 있다. ('하나에서 여럿으로' 문제의 '하나에서'에 해당되는 부분)
```python
class TestSuite:
    def add(self, test):
        self.test= test
    def run(self, result):
        self.test.run(result)
```
- 이제 데이터를 중복시킬 차례다. 일단 테스트 컬렉션을 초기화한다.
```python
class TestSuite:
    def __init__(self):
        self.tests= []
```
- test 변수를 설정하는 모든 부분에서 컬렉션도 설정하게 만든다.
```python
class TestSuite:
    def add(self, test):
        self.test= test
        self.tests.append(test)
```
- 이제 단일 테스트 대신 테스트 목록을 사용할 수 있게 됐다.
- 현재 테스트 케이스의 입장에서 볼 때 이것은 리팩토링이다.
  - 왜냐하면 현재 컬렉션 안에는 하나의 요소만 들어갈 수 있기 때문이다.
  
```python
class TestSuite:
    def run(self, result):
        for test in self.tests:
            test.run(result)
```
- 이제 쓰이지 않는 인스턴스 변수인 test를 제거한다.
```python
class TestSuite:
    def add(self, test):
        self.tests.append(test)
```
- 자바의 Vector/Enumerator에서 Collection/Iterator로 옮기는 작업 같이,
서로 다른 프로토콜을 갖는 동등한 포맷의 데이터에 대해서도 위와 같은 단계적인 데이터 이주시키기를 적용할 수 있다.
  

### 메서드 추출하기
> 길고 복잡한 메서드를 읽기 쉽게 만들려면 어떻게 해야 할까?
- 긴 메서드의 일부분을 별도의 메서드로 분리해내고 이를 호출하게 된다.

#### 방법
> 메서드 추출하기는 사실 좀더 복잡한 원자적 리팩토링의 한 가지다.
- 전형적인 예 
  - (다행히도 자동으로 메서드 추출하기 리팩토링을 수행해주는 기능은 가장 널리 구현되어 있는 기능 중 하나이므로 이 순서를 수동으로 따라해볼 일은 별로 없을 것이다.)
1. 기존의 메서드에서 별도의 메서드로 분리할 수 있을 만한 부분을 찾아낸다.
  - 반복문 내부의 코드나 반복문 전체, 혹은 조건문의 가지들이 일반적인 후보
2. 추출할 영역의 외부에서 선언된 임시 변수에 대해 할당하는 문장이 없는지 확인한다.
3. 추출할 코드를 복사해서 새 코드에 붙인다.
4. 원래 메서드에 있던 각각의 임시 변수와 매개 변수 중 새 메서드에서도 쓰이는게 있으면, 이들을 새 메서드의 매개변수로 추가한다.
5. 기존의 메서드에서 새 메서드를 호출한다.

#### 이유
- 나는 복잡한 코드를 이해하고자 할 때 메서드 추출하기를 사용한다.
- 나는 일부 서로 비슷한 내용이 있는 두 메서드에서 중복을 제거하기 위해 메서드 추출하기를 사용하기도 한다.
- 두 메서드의 비슷한 부분을 하나의 메서드로 추출해낸다.
- 추출해낸 메서드가 이미 존재하는 다른 메서드와 동일한지 검사하고,
- 새로운 메서드를 만들어내는 대신 기존의 메서드를 쓸 것인지 여부를 제안한다.

> 메서드를 작은 조각으로 나누는 것은 때때로 그 정도가 지나칠 수도 있다.
- 더 나아갈 방법이 보이지 않을 땐, 새로운 방식으로 메서드 추출하기를 하기 위해 일단 모든 코드를 한자리에
모아놓고 메서드 인라인 리팩토링을 자주 사용한다.
  

### 메서드 인라인
> 너무 꼬여있거나 산재한 제어 흐름을 단순화하려면 어떻게 해야 할까?
- 메서드를 호출하는 부분을 호출될 메서드의 본문으로 교체한다.

#### 방법
1. 메서드를 복사한다.
2. 메서드를 호출하는 부분을 지우고 복사한 코드를 붙인다.
3. 모든 형식 매개 변수를 실제 매개 변수로 변경한다.
  - 예를 들어 만약 reader.getNext() 같은 매개 변수를 전달했다면, 이를 지역 변수에 할당해주어야 할 것이다.
    (왜냐하면 reader의 내부 상태를 바꾸기 때문에)
    
#### 이유
- 초벌 원고의 검토자 중 한 사람은 1부에서 Bank가 Expression을 하나의 Money로 축약할 수 있게 한 부분이 너무 복잡한 게 아니냐는 지적을 했다.
```java
public void testSimpleAddition() {
    Money five= Money.dollar(5);
    Expression sum= five.plus(five);
    Bank bank = new Bank();
    Money reduced= bank.reduce(sum, "USD");
    assertEquals(Money.dollar(10), reduced);
}
```
- "이건 너무 복잡하네요. 그냥 Money가 스스로를 축약하게 만들지 그래요?"
- Bank.reduce()의 구현을 합쳐놓고 코드가 어떻게 바뀌는지 보자
```java
public void testSimpleAddition() {
    Money five= Money.dollar(5);
    Expression sum= five.plus(five);
    Bank bank= new Bank();
    Money reduced= sum.reduce(bank, "USD");
    assertEquals(Money.dollar(10), reduced);
}
```
- 두 번째 코드가 더 좋아 보일 수도, 아닐 수도 있다.
- 여기서 중요한 건 제어 흐름을 이리저리 바꿔가며 실헝해보기 위해서 메서드를 인라인할 수 있다는 점이다.
- 때로는 이런 열기 속에서 자신의 꾀에 빠져버리는 수가 있다.
- "이놈은 저놈에게 메시지를 보내고, 그럼 그놈은 다시... 우와 , 모르겠다"
- 이렇게 되면 나는 여러 추상화 계층을 인라인시켜 놓고 뭐가 어떻게 돌아가는지 제대로 이해한 다음,
예상이 아닌 실제적인 필요성에 기반하여 다시 추상화를 수행한다.
  

### 인터페이스 추출하기
> 자바 오퍼레이션에 대한 두 번째 구현을 추가하려면 어떻게 해야 할까?
- 공통되는 오퍼레이션을 담고 있는 인터페이스를 만들면 된다.

#### 방법
1. 인터페이스를 선언한다.
   - 새로 추가될 인터페이스의 이름을 기존 클래스의 이름을 사용해야 하는 경우,
  인터페이스를 추가하기 전에 기존 클래스의 이름을 변경해준다.
2. 기존 클래스가 인터페이스를 구현하도록 만든다.
3. 필요한 메서드를 인터페이스에 추가한다.
   - 필요하다면 클래스에 존재하는 메서드들의 가시성을 높여준다.
4. 가능한 모든 곳의 타입 선언부에서 클래스 이름 대신 인터페이스 이름을 사용하게 바꾼다.

#### 이유
- 인터페이스를 추출할 필요가 있을 경우, 때때로, 사실 첫 번째 구현에서 두 번째 구현으로 이동하고 있는 것이다.
- 사각형(Rectangle) 클래스가 있고 타원(Oval)을 추가하고 싶으면 모양(Shape)이라는 인터페이스를 만든다.
- 인터페이스를 추출할 필요가 있을 때면 때때로, 크래시 테스트 더미(Cra-sh Test Dummy)나 기타 모의 객체(Mock Object)를 도입하기도 한다.
  - 이 경우 이름 짓기가 더 힘들 수 있는데 진짜 구현 사례가 여전히 단 한가지 밖에 존재하지 않기 때문이다.
  - 이럴 때면 그냥 인터페이스 이름을 IFile이라고 하고 클래스 이름을 그냥 File로 남겨두고 싶어진다.
  - 하지만 아마도 인터페이스 이름을 File로 하고 클래스 이름을 DiskFile로 하는 것이 맞을지도 모르겠다.
  - 왜냐하면 클래스는 비트가 디스크상에 있다는 걸 가정하고 있기 때문이다.
  

### 메서드 옮기기
> 메서드를 원래 있어야 할 장소로 옮기려면 어떻게 해야 할까?
- 어울리는 클래스에 메서드를 추가해주고, 그것을 호출하게 하라

#### 방법
1. 메서드를 복사한다.
2. 원하는 클래스에 붙이고 이름을 적절히 지어준 다음 컴파일한다.
3. 원래 객체가 메서드 내부에서 참조된다면, 원래 객체를 새 메서드의 매개 변수로 추가한다.
원래 객체의 필드들이 참조되고 있다면 그것들도 매개 변수로 추가한다. 
   - 만약 원래 객체의 필드들이 갱신된다면 포기해야 한다.
4. 원래 메서드의 본체를 지우고, 그곳에 새 메서드를 호출하는 코드를 넣는다.

#### 이유
- 이것은 보증 안 되는 예상을 발견하는 데에 탁월한 방법이다.
- 면적을 계산하는 것은 Shape의 책임이다.
```java
// Shape
...
int width= bounds.right() - bounds.left();
int height= bounds.bottom() - bounds.top();
int area= width * height;
...
```
- 한 메서드에서 다른 객체에 하나 이상의 메시지를 보내는 것을 보면 나는 언제나 의심하게 된다.
- 이 경우 bounds(Rectangle 인스턴스)로 네 개의 메시지가 보내지고 있다.
- 이 부분을 옮겨야 한다.
```java
// Rectangle
public int area() {
    int width= this.right() - this.left();
    int height= this.bottom() - this.top();
    return width * height;
}

// Shape
...
int area = bounds.area();
...
```
- 메서드 옮기기의 훌륭한 세 가지 속성은 다음과 같다.
  - 코드에 대한 깊은 이해가 없더라도 언제 이 리팩토링이 필요한지 쉽게 알아낼 수 있다.
    - 다른 객체에 대한 두 개 이상의 메시지를 보내는 코드를 볼 때마다 메서드 옮기기를 해주면 된다.
  - 리팩토링 절차가 빠르고 안전하다.
  - 리팩토링 결과가 종종 새로운 사실을 알려준다.
    - "이렇게 되면 Rectangle이 아무 계산도 하지 않게 되잖아? 아하 알았다. 이렇게 하는 게 더 좋군"
  
> 때론 메서드의 일부분만 옮기고 싶을 때가 있다.
> 그럴 때는 일단 메서드 추출하기를 한 후, 메서드를 옮기고, 원래 클래스에 있던 추출된 부분을 다시 합치면 된다.


### 메서드 객체
> 여러 개의 매개 변수와 지역 변수를 갖는 복잡한 메서드를 어떻게 표현할까?
- 메서드를 꺼내서 객체로 만든다.

#### 방법
- 메서드와 같은 매개 변수를 갖는 객체를 만든다.
- 메서드의 지역 변수를 객체의 인스턴스 변수로 만든다.
- 원래 메서드와 동일한 내용을 갖는 run()이라는 이름의 메서드를 만든다.
- 원래 메서드에서는 새로 만들어진 클래스의 인스턴스를 생성하고 run()을 호출한다.

#### 이유
- 메서드의 객체는 시스템에 완전히 새로운 로직을 추가하고자 할 때 유용하다.

> 메서드 객체는 메서드 추출하기를 적용할 수 없는 코드를 간결하게 만들기 위한 용도로도 적합하다.
- 종종 한 단위의 코드가 여러 임시 변수들과 매개 변수들로 얽혀 있어서,
- 이 부분을 추출하려고 할 때마다 대여섯 개의 임시 변수와 매개 변수를 끌고 다녀야 할 때가 있다.
- 이 경우 메서드 서명부가 너무 길기 때문에 추출된 메서드도 원래의 코드보다 별로 좋아보이지 않는다.
- 메서드 객체를 생성하면 아무 것도 전달할 필요가 없는 새로운 이름공간을 얻게 된다.


### 매개 변수 추가
> 메서드에 매개 변수를 추가하려면?

#### 방법
1. 메서드가 인터페이스에 선언되어 있다면 일단 인터페이스에 매개 변수를 추가한다.
2. 매개 변수를 추가한다.
3. 컴파일 에러가 여러분에게 어딜 고쳐야 하는지 알려줄 것이다.

#### 이유
- 매개 변수를 추가하는 것은 종종 확장 단계다.
- 매개 변수 없이 첫 번째 테스트를 통과할 수 있었으나, 다음 테스트가 제시하는 새로운 상황을 제대로 완수하려면 더 많은 정보를 제공해야 하는 경우가 있다.

> 매개 변수 추가하기는 또한 하나의 데이터 표현을 다른 표현으로 변경하는 작업의 일부로 쓰이기도 한다.
- 일단 매개 변수를 추가하고, 그 다음에 기존 매개 변수를 사용하는 모든 부분을 삭제 후 기존 매개 변수를 제거하는 식이다.


### 메서드 매개 변수를 생성자 매개 변수로 바꾸기
> 하나 이상의 메서드의 매개 변수를 생성자로 옮기려면 어떻게 할까?

#### 방법
1. 생성자에게 매개 변수를 추가한다.
2. 매개 변수와 같은 이름을 갖는 인스턴스 변수를 추가한다
3. 생성자에서 인스턴스 변수의 값을 설정한다.
4. 'parameter'를 'this.parameter'로 하나씩 찾아 바꾼다.
5. 매개 변수에 대한 참조가 더 이상 존재하지 않으면 해당 매개 변수를 메서드와 모든 호출자에서 제거한다.
6. 이제 필요 없어진 'this.'을 제거한다.
7. 변수명을 적절히 변경한다.

#### 이유
- 동일한 매개 변수를 같은 객체의 서로 다른 몇몇 메서드로 전달하는 경우라면,
매개 변수를 한 번만 전달하게끔 API를 단순화 할 수 있다.
- 만약 인스턴스 변수가 오직 하나의 메서드에서만 쓰이는 경우라면 이 리팩토링을 반대로 수행할 수도 있다.


## 32장 TDD 마스터하기
### 단계가 얼마나 커야 하나?
- 사실 여기에는 두 가지 질문이 숨어 있다.
- 각 테스트가 다뤄야 할 범위는 얼마나 넓은가?
- 리팩토링을 하면서 얼마나 많은 중간 단계를 거쳐야 하는가?


1. 한 줄의 로직을 추가하고 약간의 리팩토링을 할 수 있을 정도 크기의 테스트
2. 수백 줄의 로직과 수시간 분량의 리팩토링을 할 만큼의 크기를 갖는 테스트

> 이 중 어떤 것이 옳은가?
- 둘 다 할 수 있어야 한다.
- 시간이 지남에 따라 테스트 주도 개발자의 경향은 분명히 나타난다.
- 단계가 점점 작아지는 것이다.
- 하지만 몇몇 부류는 애플리케이션 수준의 TDD를 실험하기도 한다.
- 이들 중 일부는 애플리케이션 수준의 테스트만을 작성하기도 하고,
- 또 다른 일부는 우리가 지금껏 작성해온 프로그래머 수준의 테스트와 병행하기도 한다.

> 리팩토링 초기에는 아주 작은 단계로 작업할 준비가 되어 있어야 한다.
- 수작업 리팩토링은 에러가 발생하기 쉬운데
- 그렇게 해서 더 많은 실수를 하고 그걸 나중에야 잡게 된다면
- 결국 리팩토링을 점점 덜 하게 될 것이다.
- 매우 작은 단계로 수작업 리팩토링을 20번 하고 나면, 몇 단계 건너 뛰는 실험을 해보라.


### 테스트할 필요가 없는 것은 무엇인가?
> "두려움이 지루함으로 변할때까지 테스트를 만들어라"
- 이에 대한 대답은 스스로 찾아야만 한다. 당신은 질문이 아니라 해답을 얻으려고
- 이 책을 찾았기 때문에 다음 목록을 시도해 보라
- 다음 것들을 테스트해야 한다.
1. 조건문
2. 반복문
3. 연산자
4. 다형성
- 하지만 당신이 작성하는 것들에 대해서만 테스트해라.
- 불신할 이유가 없다면 다른 사람이 만든 코드를 테스트하지 마라.


### 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?
> 테스트란 탄광 속에서 자신의 고통을 통해 고약한 설계 가스의 존재를 드러내는 카나리아다.

#### 설계 문제가 있음을 알려주는 테스트의 속성
- 긴 셋업 코드
  - 하나의 단언의 수행을 위해 수백 개의 객체 생성 코드가 필요하다면 객체가 너무 크다는 뜻. 나눌 필요가 있다.
- 셋업 중복
  - 공통된 셋업 코드를 넣어 둘 공통의 장소를 찾기 힘들다면 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻
- 실행 시간이 오래 걸리는 테스트
  - 실행 시간이 오래 걸리면 테스트를 안하게 된다.
  - 실행 시간이 길다는 것은 애플리케이션의 작은 부분만으로 따로 테스트하기가 힘들다는 것을 의미
  - 작은 부분만 테스트할 수 없음은 설계 문제를 의미한다.
  - 설계를 적절히 변경해줄 필요가 있다.
- 깨지기 쉬운 테스트
  - 예상치 못하게 실패하는 테스트는 애플리케이션의 특정 부분이 다른 부분에 이상한 방법으로 영향을 끼친다는 뜻.
  - 연결을 끊거나 합하는 것을 통해 멀리 떨어진 것의 영향력이 없어지도록 해야한다.
  

### TDD로 프레임워크를 만들려면 어떻게 해야 하나?
> 모순: 코드의 미래에 대해 고려하지 않음으로 인해, 코드가 더 뛰어난 적응성을 가질 수 있게 한다.
- TDD의 "내일을 위해 코딩하고, 오늘을 위해 설계하라"
  - 첫 번째 기능을 구현한다. : 단순하고 직관적으로 구현되는 첫 번째 기능은 짧은 시간 안에 결함도 적은 상태로 완성된다.
  - 첫 번째 기능에 대한 변주가 되는 두 번째 기능을 구현한다. : 두 기능 사이의 중복이 한 곳으로 모이고 서로 다른 부분은 다른 곳으로 옮겨진다.
  - 앞의 두 기능에 대한 변주로 세 번째 기능을 구현한다. : 공통의 로직은 약간의 수정만을 통해 재활용 가능한 상태로 만들어질 수 있을 것이다.
    - 공통적이지 않은 로직들은 다른 메서드 혹은 클래스 등 더 명확하게 로직이 있어야 할 곳에 있게 되는 경향이 있다.
  
> 개방-폐쇄 원칙
- 객체는 사용에 대해서는 열려 있어야 하고 향후 수정에 대해서는 닫혀 있어야 한다.
- 테스트 주도 개발은 비록 발생하지 않은 변주 종류는 잘 표현하지 못할지라도
발생하는 변주 종류들, 바로 그것들을 잘 표현하는 프레임워크를 만들게 해 준다.
- 3년 후에 일반적이지 않은 변화가 발생하면?
  - 개발-폐쇄 원칙을 잠시 위배하게 되지만,
  - 이에 따른 비용은 크지 않다.
  - 왜냐하면 뭔가를 잘못하지 않았다는 확신을 줄 수 있는 수 많은 테스트들이 존재하기 때문이다.
  

### 피드백이 얼마나 필요한가?
> 테스트를 얼마나 작성해야 하나?
- 삼각형의 각 변의 길이를 나타내는 세 개의 정수를 받아서 다음 값을 반환하는 문제
  - 정삼각형이면 1
  - 이등변삼각형이면 2
  - 부등변삼각형이면 3
- 제대로 된 삼각형이 아니면 예외를 던진다.
- 직접 풀어보기 > 저자는 여섯 개의 테스트를 작성했다.

> 나는 테스트를 얼마나 작성할지 고려할 때, 실패간 평균시간(MTBF, Mean Time Between Failures)를 생각한다.
- 어떤 테스트를 작성할 필요가 있을지 없을지는 당신이 MTBF를 얼마나 조심스럽게 측정하는지에 달렸다.
- TDD에서 테스트는 어떤 목적을 위한 하나의 수단이다.
- 만약 어떤 구현에 대한 지식이 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것이다.


### 테스트를 지워야 할 때는 언제인가?
- 첫째 기준은 자신감이다.
  - 삭제할 경우 자신감이 줄어들 것 같은가? 지우지 말아야 한다.
- 둘째 기준은 커뮤니케이션이다.
  - 두 테스트가 동일한 부분을 실행하더라도 이 둘이 서로 다른 시나리오를 말한다면 그대로 남겨두자
  
> 이렇게 말하긴 했지만, 자신감이나 커뮤니케이션 면에서 별 부가적인 이득이 없는 중복된 테스트가 두 개 있다면, 덜 유용한 것을 삭제하라


### 프로그래밍 언어나 환경이 TDD에 어떤 영향을 주는가?
> TDD 주기를 수행하기가 힘든 언어나 환경에서 작업하게 되면 단계가 커지는 경향이 있다.
- 각 테스트가 더 많은 부분을 포함하게 만든다.
- 중간 단계를 덜 거치고 리팩토링을 한다.


### 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가?
> 시스템에 있는 기능의 양은 TDD의 효율에 영향을 미치지 않는 것 같다.
- 중복을 제거함에 따라 더 작은 객체들이 만들어지게 되고
- 이 작은 객체들은 애플리케이션의 크기와 무관하게 독립적으로 테스트될 수 있다.


### 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?
- 작은 규모의 테스트로 개발을 주도하는 것의 문제는 실제로 사용자가 원하지 않는데
그들이 원할거라 생각하고 구현할 수도 있는 위험을 끌고 간다는 점에 있다.

> 애플리케이션 수준에서 테스트를 작성한다면 어떨까?
- 프로그래머에게 약간의 도움을 받아서 사용자가 직접 원하는 바를 테스트로 작성할 수 있을 것이다.
- 하지만 여기에는 기술적 문제가 있다.
- '고정물을 만드는것'
- 아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가?
- 전형적인 방법은 아직 어떻게 해석해야 할지 모르는 테스트를 만났을 때
- 우아하게 에러를 뱉어내는 해석기(interpreter)를 도입하는 것이다.

> 애플리케이션 테스트 주도 개발(ATDD) 의 사회적인 문제
- 테스트를 작성하는 것은 사용자에게는 기존에 없던 새로운 책임이 되는 것이다.
- 이 책임은 '구현하기 전'이라는 기존에 존재하지 않던 단계에서 수행되어야 한다.
- 조직은 이런 종류의 책임 이동에 저항한다.
- 애플리케이션 테스트를 우선적으로 작성하기 위해서는 협조 노력하는 것이 필요하다.

> 이 책에서 설명한 TDD를 적용할지 말지는 완전히 여러분에게 달렸다.
- 원한다면 오늘 당장이라도 적용할 수 있다.
- 애플리케이션 고정물 만들기의 기술적 문제나 사용자 작성 테스트 주변의 조직 변화 이슈들을 다루는 것은 성공과는 거리가 있다.
- 단일 단계 테스트 규칙이 적용된다.
- 일단 일을 할 때 빨강/초록/리팩토링 주기가 제대로 돌아가게 하고 그 후에 그 메시지를 퍼뜨리도록 하라

> ATDD의 또다른 문제
- 테스트와 피드백 사이의 길이
- 만약 고객이 테스트를 만들고 그 테스트가 통과하길 기다리는 동안 열흘이 걸린다면?
- 거의 대부분의 시간을 빨간 막대를 보며 지내게 될 것.
- 내 생각엔 난 앞으로도 프로그래머 수준의 TDD를 원할 것 같다. 따라서
  - 즉시 초록 막대를 볼 수 있고
  - 내부 설계를 단순화할 수 있도록 할 수 있길 원한다.
  
### 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까?
> 어느 정도 작동하는 코드가 상당량 있다.
- 가장 큰 문제는 테스트를 염두에 두지 않고 만든 코드는 테스트 하기가 그리 쉽지 않다는 점이다.
- 일부분만을 격리해서 실행하고 결과를 검사할 수 있게끔 인터페이스가 설계되어 있지 않다.
- 아직 테스트가 없기 때문에 에러가 생겼다는 점을 알아낼 수 없을 것.

> 확실히 하지 말아야 할 것은 코드 전체를 위한 테스트를 그리고 코드 전체를 한번에 리팩토링 하는 것.
- 이런 작업은 오랜 시간 (몇 달..)을 소요한다. 그 시간 동안 아무런 새로운 기능도 추가로 구현하지 못할 것이다.
- 따라서 우선 해야 할 일은 변경의 범위를 제한 하는 것.
- 시스템에서 극적으로 단순화될 수 있지만 지금 당장 변할 필요가 없는 부분을 봤다면
- 그냥 그대로 놔둘 것

> 다음으로 할 일은 테스트와 리팩토링 사이에 존재하는 교착상태(deadlock)를 풀어주는 것
- 테스트가 아닌 방법으로도 피드백을 얻을 수 있다
  - 아주 조심스럽게 작업하는 방법
  - 파트너와 함께 작업 하는 방법
- 우리는 전체적인 레벨에서 피드백을 얻을 수 있는데
- 이것은 충분하지 않지만 어느 정도의 확신을 주는 시스템 레벨의 테스트와 비슷하다.
- 이 피드백을 이용해 우리가 바꾸어야 하는 부분이 변화에 좀 더 수용적이 되도록 할 수 있다.


### TDD는 누굴 위한 것인가?
- TDD는 더 깔끔한 설계를 할 수 있도록,
- 그리고 더 많은 것들을 배워감에 따라 설계를 더 개선할 수 있도록,
- 적절한 때 적절한 문제에 집중할 수 있게끔 도와준다.

> 성공의 유일한 길은 깔끔한 코드라는 가정이다.
- 훌륭한 엔지니어링은 아마도 프로젝트 성공의 20%에 지나지 않을 것이다.
- 형편없는 엔지니어링은 분명 프로젝트를 가라앉게 할 것이지만,
- 나머지 80%가 어느 정도 제대로 되는 한 적당한 수준의 엔지니어링만으로도 프로젝트가 성공할 수 있다.

> 이 시각에서 보면 TDD는 오버액션이다.
- 그렇지만 우아함에서 영혼의 안식을 찾는 이들은 선을 실행하면서 잘 사는 방법을 TDD에서 찾을 수 있다.

> TDD는 시간이 지남에 따라 코드에 대한 자신감을 점점 더 쌓아갈 수 있게 해준다.
- 나의 목적은 처음 반짝이는 눈빛으로 프로젝트를 시작 할 때보다
- 프로젝트를 시작하고 1년이 지난 후에 더 좋은 느낌을 갖게 되는 것.
- TDD가 이 목적을 달성할 수 있도록 도와준다.


### 어째서 TDD가 잘 작동하는가?
> 나는 TDD를 시작한 이후로 스트레스를 훨씬 적게 받게 됐다.
- 모든 것에 대해 한꺼번에 걱정할 필요가 없게 됐다.
- 나는 직면한 테스트 하나를 실행하게 할 수 있고,
- 그 뒤엔 나머지를 전부 실행할 수도 있다.
- 팀원들과의 관계도 더 긍정적으로 변했다.
- 나는 더 이상 빌드를 망가뜨리지 않았고
- 사람들은 내 소프트웨어로 작업하는 것을 신뢰할 수 있었다.
- 내 시스템의 고객들도 더욱 긍정적으로 변했다.
- 새로 릴리즈한 시스템은 이제 더 이상 새로운 버그의 근원지가 아니고,
- 단지 새로운 기능만을 더 제공하게 되었다.

> 플립의 "왜 TDD가 잘 작동하나?"에 대한 대답
- 올바른 코드를 절대치가 아니라 극한 함수로서 '끌어들이는' 프로그래밍 실행법을 도입하라.
- 이 끌개라는 것은 모든 흐름이 그곳으로 수렴하는 상태 공간의 점이다.
- 이것은 코드가 시간이 지남에 따라 더 나빠지기보다
- 더 좋아지도록 하는 경향이 있다.
