# 5장. 구부러지거나 부러지거나

결합도 줄이기와 디미터 법칙

- 서로 다른 개념들을 분리하여 결합도를 줄이는 방법에 대해

메타프로그래밍

- 세부사항을 완전히 코드 밖으로 옮기는 방법에 대해

시간적 결합

- 결합도와 관련하여 시간을 두 측면에서 살펴보기

단지 뷰일 뿐이야

- 뷰와 모델의 결합도를 줄이는 방법

칠판

- 모듈들이 데이터를 동기적, 비동기적으로 교환할 수 있는 만남의 장소를 마련해 줌으로써 모듈 간 결합도를 획기적으로 줄이는 기술

실용주의 프로그래머 tip

- 36 : 모듈간의 결합도를 최소화하라
- 37 : 통합하지 말고 설정하라
- 38 : 코드에는 추상화를 메타데이터에는 세부 내용을
- 39 : 작업흐름 분석을 통해 동시성을 개선하라
- 40 : 서비스를 사용해서 설계하라
- 41 : 언제나 동시성을 고려해 설계하라
- 42 : 모델에서 뷰를 분리하라
- 43 : 칠판을 사용해 작업흐름을 조율하라

# 결합도 줄이기와 디미터 법칙

- 어떤 객체에게 특정 서비스를 요청했을 때 이 요청을 바로 처리해주기 바라지, 제 3의 객체를 넘겨받아 이미 요청한 서비스를 가지고 이러쿵저러쿵 하고 싶지는 않을 것
- 불필요한 의존이 많은 시스템은 유지보수하기 어렵고 이로 인해 비용이 많이 들며 시스템 자체가 매우 불안정함
- 의존도를 최소화 하기 위한 디미터 법칙 사용

### 디미 함수 법칙

- 디미터 함수 법칙은 프로그램에서 모듈간 결합도를 최소화하려 시도
- 디미터 함수 법칙은 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다

### 확실한 차이를 낳는가?

- 응답집합이 큰 클래스는 작은 클래스보다 에러를 발생시키기 쉽다
- 이때 응답집합은 클래스의 메서드가 직접 호출하는 함수의 수를 의미
- 디미터 법칙과 반대로 여러 모듈의 결합도를 높힘으로써 중요한 성능향상을 꾀할 수도 있음
- 해당 모듈들이 서로 결합하고 있다는 것을 잘 알고, 또 그것을 받아들일 수 있다면 아직 괜찮은 설계라고 할 수 있음

## 메타프로그래밍

- 세부항을 코드에서 몰아내면 매우 설정 가능하게되고 소프트 해진다
- 변화에 쉽게 적응할 수 있게 되는 것
- 메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술하라
- 메타데이터란?
    - 데이터에 관한 데이터
        - 데이터베이스 스키마, 데이터 디렉터리 등
    - 애플리케이션을 기술하는 모든 데이터
        - 애플리케이션이 어떻게 실행되어야 하고, 어떤 자원을 이용해야 하는지 등을 기술

### 메타데이터 주도 애플리케이션

- 가능한 많은 메타데이터를 써서 애플리케이션을 설정하고 실행시켜라
- 우리의 목표는 무엇을 해야 하는지를 명시함으로써 선언적으로 생각하는 것
- 이로써 더 동적이고 적응가능한 프로그램을 만드는 것

### 도도 코드를 작성하지 말라

- 메타데이터를 사용하지 않는다면 코드는 최대한의 적응성이나 유연성을 얻을 수 없다
- 도도는 인간과 가축의 등장에 적응하지 못했고, 빠르게 멸종됐다
- 프로젝트가 도도의 전철을 밟지 않도록 하라

## 시간적 결합

- 소프트웨어의 설계 요소 자체로서의 시간의 역할에 대한 이야기
- 직선적 사고의 방식으로 생각하다 보면 시간 측면에서의 결합을 만들게 된다.
    - 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다
    - 보고서는 한 번에 오직 하나만 실행될 수 있다
    - 똑은 딱보다 먼저 일어나야 한다

### 작업흐름

- 동시에 일어나도 되는 것은 어떤 것이고, 엄격한 순서에 따라 일어나야 하는 것은 어떤 것인지 찾아내는 것이 필요
- UML 활동 다이어그램 같은 표기법을 사용해서 사용자들이 기술해 준 작업흐름을 기록하는 것이 한 방법
- 활동 다이어그램을 사용하면 동시에 수행될 수 있지만 아직 그렇지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다

### 작업흐름의 예시

1. **믹서를 연다**
2. **피냐콜라다 믹스 병뚜껑을 연다**
3. 피냐콜라다 믹스를 믹서에 넣는다
4. **화이트럼 1/2 컵을 잰다**
5. 럼을 믹서에 붓는다
6. 얼음 두 컵을 넣는다
7. 믹서를 닫는다
8. 2분 동안 돌린다
9. 믹서를 연다
10. **잔을 가져온다**
11. **분홍색 우산 장신을 가져온다**
12. 차려낸다
- 최상위 작업들 (1, 2, 4, 10, 11번)은 제일 먼저, 동시에 수행될 수 있는 일들
- 그 후 3번, 5번, 6번 작업이 동시에 수행

### 동시성을 고려한 설계

- 쓰레드를 쓰는 프로그래밍 받는 설계상의 몇 가지 제약 → 좋은 일
- 이 제약들은 도움이 많이 되어 다른 어떤 프로그래밍을 하더라도 꼭 지키고 싶어지는 것
- 제일 먼저 모든 전역 변수나 정적 변수들을 동시 접근으로부터 보호해야 함
    - 전역 변수가 필요했는지 물을 수 있는 기회

### 더 깔끔한 인터페이스

- 동시성과 시간 순서에 따른 의존성을 고려하는 것은 더 깔끔한 인터페이스를 설계하는 방향으로 이끌기도 함

### 배치

- 동시성 요소가 포함된 아키텍처를 설계한 다음에는 수많은 동시적 서비스들을 다루는 것에 대해 생각하기도 더 쉬워짐
- 동시성 모델은 도처에 스며든다
- 시스템을 독립적인 서비스들로 구성된 아키텍처로 만듦으로써 설정 역시 동적으로 만들 수 있다
- 동시성을 허용하도록 설계한다면, 확장가능성이나 성능에 대한 요구사항이 들어올 때 더 쉽게 그것에 맞추어 줄 수 있다
- 깔끔한 설계의 이점

## 단지 뷰일 뿐이야

- 잘 정의된 단 하나의 책임만 가지는 것
- 하지만 프로그램을 책임에 따른 여러 모듈로 나눈 다음에도 새로운 문제가 생김
    - 런타임에 객체들이 어떻게 서로 이야기하게 만들어야 하나?
    - 모듈 사이의 논리적 의존성은 어떻게 관리해야 하나?
    - 여러 다른 객체들의 상태변화를 어떻게 동기화해야 할까
- 이벤트를 이용하면 어떤 객체의 상태 변화를 이에 관심을 가질 다른 객체들에게 알릴 수 있다
- 이벤트를 이용하여 객체들 사이의 결합을 최소화할 수 있음
- 하지만 이벤트를 이용하려면 조심스러워야 함
    - 자바의 초기 버전에서는 루틴 하나가 애플리케이션에서 나오는 모든 이벤트를 다 받아야 했음
    - 분명 유지보수나 개선을 하기 쉽게 해주는 길은 아님

### 출판/구독

- 모든 이벤트를 루틴 하나에 몰아넣은 일은 왜 나쁠까
    - 객체 캡슐화에 위배되기 때문
    - 단 하나의 루틴이 여러 객체들 사이의 상호작용에 대한 상세한 지식을 지니게 됨
    - 결합도도 증가됨
    - 객체 또한 이벤트에 대한 지식을 가져야만 하기 때문에 DRY 원칙, 직교성, 제네바 협약 항목도 어길 것
- 객체가 자기가 필요한 이벤트들만 구독해서 받아오고 필요하지 않은 이벤트들은 받아오지 않도록 해야 함

## 칠판

- 칠판 시스템을 이용하면, 지식의 소비자와 생산자들이 익명으로 그리고 비동기적으로 데이터를 주고받는 공간이 생김
- 객체들 사이의 결합을 완전히 끊을 수 있음
- 사건을 조사하면서 누구라도 증인에게 질문을 하고, 질문과 대답을 적은 기록을 칠판에 올리고, 증인을 칠판의 다른 영역으로 옮겨도 된다
- 그렇게 해서 위치가 바뀐 증인이 다른 반을을 보이는 경우도 있다
- 인터페이스와 상호작용들의 조합이 폭발하게 되면, 프로젝트는 금세 악몽으로 바뀌어버린다
- 칠판을 이용하는 방식의 프로그래밍을 하면 이렇게 많은 인터페이스가 필요 없어지기 때문에 더 우아하고 일관성 있는 시스템을 만들 수 있다