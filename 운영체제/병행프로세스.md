# 병행 프로세스

# 병행성

### 병행성(concurrency)

- 여러 개의 프로세스 또는 쓰레드가 동시에 실행되는 시스템의 특성

### 병행 프로세스

- 동시에 실행되는 여러 개의 프로세스 또는 쓰레드

## 병행 프로세스의 실행 형태

### CPU의 개수에 따른 병행 프로세스의 실행 형태

- 하나의 CPU에서 인터리빙 형식으로 실행
    - 하나를 잘게 쪼개서 계속 돌리면서 사용하는 방식
- 여러 개의 CPU에서 병렬 처리 형식으로 실행
    - CPU별로 프로세스 하나씩 처리 프로세스 개수 = CPU 개수

### 메모리 구조에 따른 병행 프로세스의 실행 형태

- 강결합 멀티프로세서 시스템
    - `공유 메모리 구조`
    - 하나의 메모리를 여러 CPU가 공유해서 사용
- 약결합 멀티프로세서 시스템
    - `분산 메모리 구조`
    - CPU마다 메모리가 각각 존재
    - 통신선을 활용해서 메모리를 주고받음

## 병행성 문제

### 병행 프로세스들이 상호작용 하는 경우 발생

- 공유자원 점유 문제
    - 특정 자원을 여러 프로세스들이 사용하려고 하는 것
    - 누가 사용하게 할 것인지?
- 동기화 문제
    - 프로세스 사이의 순서 관계를 정하는 문제
    - A → B 순서여야 하는데 B → A 면 안된다
- 통신 문제
    - 분산 메모리 같은 경우에 어떻게 데이터등을 주고 받을 것인지


### 상황에 따른 구분

**단일 프로세스 내의 병행성**

```java
S1 : a := x + y;
S2 : b := z + l;
S3 : c := a + b;
S4 : write(c);
```

- 이 경우 a와 b가 실행된 후 c가 실행되어야 하고, c가 실행된 후 마지막 출력문이 실행되어야 한다.
- 어떻게 해결할 수 있을까?
- `우선순위 그래프` (DAG)
    - 정점 : 문장
    - 방향 있는 간선 : 우선순위 관계

```java
(S1) (S2)
  ↘︎  ↙︎
  (S3)
   ↓
  (S4)
```

- 우선 순위에 따라서 방향 있는 간선으로 연결
- S1, S2는 서로 연결관계 X → 병행성의 관계를 가지고 있다고 볼 수 있음
- `Fork/Join 구조`
    - fork L : 2개의 병행 수행을 만듦(레이블 L 위치, fork 명령어 다음)
    - join n : 병행하는 n개의 흐름을 하나로 재결합

```java
 count := 2;
 fork L1;
 a := x + y;
 go to L2;
L1 : b := z + l;
L2 : join count;
 c := a + b;
 write(c);
```

- `병행문`
    - 1개의 프로세스가 여러 가닥의 병령 프로세스로 분할되었다가 다시 하나로 결합
    - parbegin / parend 문

```java
S0;
parbegin
 S1;
 S2;
 .
 .
 .
 Sn;
parend
Sn+1; 
```

```java
parbegin
	a := x + y;
	b := z + l;
parend
	c := a + b;
	write(c);
```

**프로세스 간의 병행성**

- `비동기 병행 프로세스`

![img/1.png](img/1.png)

# 동기화와 임계영역

### 프로세스 동기화

- 2개 이상의 프로세스에 대한 처리순서를 결정하는 것
- 예) 동시에 사용할 수 없는 공유자원, 한 프로세스의 처리 결과에 따라 다른 프로세스의 처리가 영향을 받는 경우

### 임계영역

- 2개 이상의 프로세스가 동시에 액세스하면 안되는 공유자원을 액세스하는 코드 영역

### 상호배제

- 2개 이상의 프로세스가 동시에 임계영역에 집입하지 못하도록 하는 것

## 임계영역의 예

### 상호배제를 통한 프로세스 동기화

- 프로세스 A가 실행되고 있을 떈 다른 프로세스가 공유자원에 접근하지 못하도록 함

### 임계영역을 갖는 프로세스의 일반적 구조

```java
repeat
 진입영역
 임계영역
 해제영역
 잔류영역
until false;
```

### 임계영역 문제 해결을 위한 요구조건

- 상호배제
    - 한 프로세스가 임계영역에서 실행 중일 때 다른 어떤 프로세스도 임계영역에서 실행될 수 없음
- 진행
    - 임계영역에서 실행 중인 프로세스가 없고, 여러 프로세스가 임계영역에 진입하고자 할 때
    - 그 중에서 적절히 한 프로세스를 결정해야 하며 이 결정은 무한정 미룰 수 없음
- 제한된 대기
    - 계속해서 대기할 수 없음. 임계영역에 들어갈 수 있는 기회를 제공해줘야 함

### 임계영역 문제 해결을 위한 도구

- `Test-and-Set` 명령어 (TS 명령어)
    - 상호배제의 하드웨어적 해결 방법
    - 분리가 불가능한 단일 기계 명령어(원자적으로 수행)

```basic
function Test_and_Set(var target: boolean): boolean;
	begin
		Test_and_Set:= target;
		target:= true;
	end
```

- 상호배제의 구현

```basic
repeat
	while Test_and_Set(lock) do skip; // lock의 초기값은 false
	임계영역
	lock:= false;
	잔류영역
until false;
```

- 문제점
    - 많은 프로세스가 임계영역에 들어가기를 원할 떄 기아가 발생할 수 있음
    - Busy waiting을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클 낭비
- `세마포어` (semaphore)
    - Dijkstra 가 제안한 동기화 도구
    - 세마포어 s: 사용 가능한 자원의 수 또는 잠김/열림 등의 상태를 나타내는 값을 저장하는 정수형 공용변수
    - 세마포어 s는 두 표준단위 연산 P와 V에 의해서만 접근됨

```basic
// P(s) : 검사, 감소시키려는 시도
if ( s > 0 ) then
	s := s-1;
else
	현재의 프로세스 대기;

// V(s) : 증가
if (1개 이상의 프로세스가 대기 중) then
	그 중 1개의 프로세스만 진행;
else
	s := s+1;
```

- 상호배제의 구현

```basic
repeat
	P(mutex); // 세마포어 mutex의 초기값은 1
	임계영역
	V(mutex);
	잔류영역
until false;
```

- 동기화 문제 해결
    - 프로세스1이 문장 S1을 실행한 후
    - 프로세스2가 문장 S2를 실행하도록 동기화(block/wakeup 프로토콜)


# 동기화와 임계영역

### 프로세스 동기화

- 2개 이상의 프로세스에 대한 처리순서를 결정하는 것
- 예) 동시에 사용할 수 없는 공유자원, 한 프로세스의 처리 결과에 따라 다른 프로세스의 처리가 영향을 받는 경우

### 임계영역

- 2개 이상의 프로세스가 동시에 액세스하면 안되는 공유자원을 액세스하는 코드 영역

### 상호배제

- 2개 이상의 프로세스가 동시에 임계영역에 집입하지 못하도록 하는 것

## 임계영역의 예

### 상호배제를 통한 프로세스 동기화

- 프로세스 A가 실행되고 있을 떈 다른 프로세스가 공유자원에 접근하지 못하도록 함

### 임계영역을 갖는 프로세스의 일반적 구조

```java
repeat
 진입영역
 임계영역
 해제영역
 잔류영역
until false;
```

### 임계영역 문제 해결을 위한 요구조건

- 상호배제
  - 한 프로세스가 임계영역에서 실행 중일 때 다른 어떤 프로세스도 임계영역에서 실행될 수 없음
- 진행
  - 임계영역에서 실행 중인 프로세스가 없고, 여러 프로세스가 임계영역에 진입하고자 할 때
  - 그 중에서 적절히 한 프로세스를 결정해야 하며 이 결정은 무한정 미룰 수 없음
- 제한된 대기
  - 계속해서 대기할 수 없음. 임계영역에 들어갈 수 있는 기회를 제공해줘야 함

### 임계영역 문제 해결을 위한 도구

- `Test-and-Set` 명령어 (TS 명령어)
  - 상호배제의 하드웨어적 해결 방법
  - 분리가 불가능한 단일 기계 명령어(원자적으로 수행)

```basic
function Test_and_Set(var target: boolean): boolean;
	begin
		Test_and_Set:= target;
		target:= true;
	end
```

- 상호배제의 구현

```basic
repeat
	while Test_and_Set(lock) do skip; // lock의 초기값은 false
	임계영역
	lock:= false;
	잔류영역
until false;
```

- 문제점
  - 많은 프로세스가 임계영역에 들어가기를 원할 떄 기아가 발생할 수 있음
  - Busy waiting을 함으로써 다른 작업이 사용할 수 있는 CPU 사이클 낭비
- `세마포어` (semaphore)
  - Dijkstra 가 제안한 동기화 도구
  - 세마포어 s: 사용 가능한 자원의 수 또는 잠김/열림 등의 상태를 나타내는 값을 저장하는 정수형 공용변수
  - 세마포어 s는 두 표준단위 연산 P와 V에 의해서만 접근됨

```basic
// P(s) : 검사, 감소시키려는 시도
if ( s > 0 ) then
	s := s-1;
else
	현재의 프로세스 대기;

// V(s) : 증가
if (1개 이상의 프로세스가 대기 중) then
	그 중 1개의 프로세스만 진행;
else
	s := s+1;
```

- 상호배제의 구현

```basic
repeat
	P(mutex); // 세마포어 mutex의 초기값은 1
	임계영역
	V(mutex);
	잔류영역
until false;
```

- 동기화 문제 해결
  - 프로세스1이 문장 S1을 실행한 후
  - 프로세스2가 문장 S2를 실행하도록 동기화(block/wakeup 프로토콜)

# 프로세스의 상호협력

## 병행 프로세스들의 상호협력

- 공통작업을 수행하기 위해 서로 협동하는 경우
- 예 : 생산자/소비자 문제, 판독기/기록기 문제

### 생산자/소비자 문제

- 유한 버퍼 문제
  - 생산자가 넣을 수 있는 한계가 있는 버퍼
  - 생산자 프로세스 : 버퍼에 데이터를 채우는 프로세스
  - 소비자 프로세스 : 버퍼에 있는 데이터를 읽어내는 프로세스
    - 두 프로세스간 `상호배제` 필요
  - 버퍼가 가득 차 있다면 생산자는 대기해야 함
  - 버퍼가 비어 있다면 소비자는 대기해야 함
    - 두 프로세스간 `동기화` 필요
  - 문제의 해결
    - `세마포어` 이용 - mutex, empty, full
    - 상호배제
      - mutex의 초깃값 1
    - 동기화
      - full의 초깃값 0
      - empty의 초깃값 n

### 판독기/기록기 문제

- 여러 개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제 없음
- 기록기가 다른 기록기 또는 판독기와 동시에 공유 데이터 객체에 접근하는 것은 문제
  - 상호배제 필요
- 우선순위에 따른 문제의 변형
  - 제 1판독기/기록기 문제 (`판독기 우선`)
    - 기록기가 이미 공유객체의 사용을 허가 받은 것이 아니라면 판독기는 대기하지 않음
    - → 기록기의 기아상태 유발 가능
  - 제 2판독기/기록기 문제 (`기록기 우선`)
    - 일단 기록기가 준비되었다면 기록을 가능한 한 빨리 수행하도록
    - → 판독기의 기아상태 유발 가능
  - 문제의 해결
    - 세마포어 이용 - mutex, wrt
    - 상호배제
      - wrt의 초깃값 1
    - 판독기 우선
      - 변수 readcount의 초깃값 0
      - 아무도 읽고 있지 않다면 읽기 수행
      - mutex의 초깃값 1

# 프로세스 간의 통신

## 프로세스 간의 통신(IPC, InterProcess Communication)

### 병행 프로세스 사이의 통신을 위한 방법

- 공유기억장치 기법
- 메시지 시스템 기법

### 두 방법은 상호 배타적이 아님

- 단일 운영체제 내에서 동시에 사용 가능

### 공유기억장치 기법

- 프로세스 간에 `공유변수`를 이용하여 정보를 교환
- 예 : 유한 버퍼
- 커널 활용 X → 고속 통신 가능
- 통신기능 제공의 책임: 응용 프로그래머

### 메시지 시스템 기법

- 메시지 교환방식으로 정보를 교환
- send/receive 연산자
- 커널을 활용함 → 느림
- 소량의 데이터 교환에 유용
- 통신기능 제공의 책임: 운영체제
- 통신 링크
  - 프로세스들 사이에 메시지를 주고받기 위한 연결통로
- 논리적 구현에 대한 이슈
  - 어떻게 링크를 설정?
  - 한 링크가 2개 이상의 프로세스와 연결 가능?
  - 두 프로세스 사이에 얼마나 많은 링크 존재?
  - 링크의 용량은? 메시지의 크기는? 링크는 단방향인가 양방향인가?
- 직접 통신
  - 메시지 전달 연산에 수신자나 송신자 이름 명시
  - 통신 링크는 자동 설정
  - 하나의 링크는 두 프로세스 사이만 연관 → 정확히 하나의 링크 존재
  - 링크는 양방향
  - 대칭형
    - 양쪽 다 상대 프로세스만 명시
  - 비대칭형
    - 상대 프로세스가 아닌 변수를 명시
    - 유연성
- 간접 통신(우편함)
  - 메시지 전달 연산에 우편함 이름을 명시
  - 통신 링크는 공유 우편함이 있는 경우에만 설정
  - 하나의 링크는 2개 이상의 프로세스들과 연관될 수 있음
  - 각 통신 프로세스 쌍 사이에 여러 링크 존재
  - 링크는 단방향 또는 양방향
  - 우편함이 프로세스에 소속되는 경우 해당 프로세스만 수신 가능 다른 프로세스는 송신만
  - 우편함이 운영체제에 소속되는 경우 수신권을 넘겨주는 경우 양방향이 가능
- 링크의 용량
  - ‘0’의 용량
    - 링크 자체에 보관 X
  - 제한된 용량
    - 링크에 버퍼(큐)가 있음 → 저장 가능, 저장 가능한 용량 정해져있음
    - 큐가 가득 차면 송신자는 대기
  - 무제한 용량
    - 저장 가능한 용량이 무제한
    - 송신자는 대기할 필요가 없음
  - 용량이 지정된 경우 → 자동 버퍼링
  - ‘0’ 의 경우 동기화가 필요함
  - ‘0’ 용량이 아닌 경우 메시지 도착 여부의 인지 방법
    - 받은 프로세스가 보낸 쪽에 “ack” 답신
    - 보낸 쪽은 받은 메시지에 “ack” 이 있으면 잘 갔구나 확인 가능
    - → `비동기적 통신`
- 예외조건 처리
  - 프로세스가 종료된 경우
    - `송신 프로세스` Q가 종료된 경우
      - 수신할 P를 종료 하거나
      - Q가 종료한 사실을 P에 알림
    - `수신 프로세스` Q가 종료된 경우
      - 버퍼가 없을 경우 위와 동일
  - 메시지를 상실한 경우
    - 프로세스 P — M — 프로세스 Q
    - M이 상실될 경우..!
      - 운영체제가 탐지 후 메시지 재전송
      - 송신 프로세스가 탐지 후 메시지 재전송
      - 운영체제가 탐지 후 송신 프로세스에게 통지
      - *탐지방법 : 시간제한
  - 메시지가 혼합된 경우
    - 프로세스 P — M - M’ - 프로세스 Q
    - M이 M’으로 변경되었을 경우..!
      - 오류 탐지 후 재전송
      - *탐지방법 : checksum